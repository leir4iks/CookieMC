--- a/net/minecraft/util/SortedArraySet.java
+++ b/net/minecraft/util/SortedArraySet.java
@@ -12,42 +_,33 @@
 public class SortedArraySet<T> extends AbstractSet<T> implements ca.spottedleaf.moonrise.patches.chunk_system.util.ChunkSystemSortedArraySet<T> { // Paper - rewrite chunk system
     private static final int DEFAULT_INITIAL_CAPACITY = 10;
     private final Comparator<T> comparator;
+    private final boolean isNaturalOrder; // Canvas - improve sorting
     T[] contents;
     int size;
 
     // Paper start - rewrite chunk system
     @Override
     public final boolean removeIf(final java.util.function.Predicate<? super T> filter) {
-        // prev. impl used an iterator, which could be n^2 and creates garbage
+        // Canvas start - Make removeIf slightly faster
         int i = 0;
         final int len = this.size;
         final T[] backingArray = this.contents;
 
-        for (;;) {
-            if (i >= len) {
-                return false;
-            }
-            if (!filter.test(backingArray[i++])) {
-                continue;
-            }
-            break;
-        }
-
-        // we only want to write back to backingArray if we really need to
-
-        int lastIndex = i - 1; // this is where new elements are shifted to
-
-        for (; i < len; ++i) {
-            final T curr = backingArray[i];
-            if (!filter.test(curr)) { // if test throws we're screwed
-                backingArray[lastIndex++] = curr;
-            }
-        }
-
-        // cleanup end
-        Arrays.fill(backingArray, lastIndex, len, null);
+        // Find first element to remove
+        while (i < len && !filter.test(backingArray[i])) i++;
+        if (i == len) return false;
+
+        // Shift elements in-place
+        int lastIndex = i;
+        for (i++; i < len; i++) {
+            T curr = backingArray[i];
+            if (!filter.test(curr)) backingArray[lastIndex++] = curr;
+        }
+
+        // Only update size - skip Arrays.fill (safe in ChunkHolderManager's context)
         this.size = lastIndex;
         return true;
+        // Canvas end - Make removeIf slightly faster
     }
 
     @Override
@@ -93,6 +_,7 @@
 
     private SortedArraySet(int initialCapacity, Comparator<T> comparator) {
         this.comparator = comparator;
+        this.isNaturalOrder = comparator == Comparator.naturalOrder(); // Canvas - improve sorting
         if (initialCapacity < 0) {
             throw new IllegalArgumentException("Initial capacity (" + initialCapacity + ") is negative");
         } else {
@@ -121,9 +_,51 @@
     }
 
     private int findIndex(T object) {
-        return Arrays.binarySearch(this.contents, 0, this.size, object, this.comparator);
-    }
-
+        return isNaturalOrder ? naturalBinarySearch(object) : customBinarySearch(object); // Canvas - improve sorting
+    }
+
+    // Canvas start - improve sorting
+    private int naturalBinarySearch(T object) {
+        int low = 0;
+        int high = this.size - 1;
+        final Comparable<? super T> key = (Comparable<? super T>) object;
+        final T[] a = this.contents;
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            T midVal = a[mid];
+            int cmp = key.compareTo(midVal);
+            if (cmp < 0) {
+                high = mid - 1;
+            } else if (cmp > 0) {
+                low = mid + 1;
+            } else {
+                return mid;
+            }
+        }
+        return -(low + 1);
+    }
+
+    private int customBinarySearch(T object) {
+        int low = 0;
+        int high = this.size - 1;
+        final T[] a = this.contents;
+        final Comparator<T> c = this.comparator;
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            T midVal = a[mid];
+            int cmp = c.compare(midVal, object);
+            if (cmp < 0) {
+                low = mid + 1;
+            } else if (cmp > 0) {
+                high = mid - 1;
+            } else {
+                return mid;
+            }
+        }
+        return -(low + 1);
+    }
+
+    // Canvas end
     private static int getInsertionPosition(int index) {
         return -index - 1;
     }
