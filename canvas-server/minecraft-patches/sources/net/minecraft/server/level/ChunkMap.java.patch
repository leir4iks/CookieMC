--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1,15 +_,25 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.concurrentutil.util.Priority;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.collect.ImmutableList.Builder;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
+import io.canvasmc.canvas.util.ConcurrentRegionizedEntityMap;
+import io.canvasmc.canvas.util.fastutil.Int2ObjectConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.Long2ByteMaps;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2LongMap;
 import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
@@ -36,7 +_,12 @@
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiFunction;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.IntConsumer;
@@ -56,14 +_,13 @@
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundChunksBiomesPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
 import net.minecraft.util.StaticCache2D;
 import net.minecraft.util.TriState;
-import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.util.thread.ConsecutiveExecutor;
 import net.minecraft.world.entity.Entity;
@@ -133,9 +_,11 @@
     public final ChunkMap.DistanceManager distanceManager;
     public final AtomicInteger tickingGenerated = new AtomicInteger();  // Paper - public
     private final String storageName;
-    private final PlayerMap playerMap = new PlayerMap();
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
-    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
+    // private final PlayerMap playerMap = new PlayerMap(); // Canvas - Threaded Regions
+    // Canvas start - synchronize / concurrent
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap; // Canvas - Threaded Regions
+    private final Long2ByteMap chunkTypeCache = Long2ByteMaps.synchronize(new Long2ByteOpenHashMap());
+    // Canvas end
     // Paper - rewrite chunk system
     public int serverViewDistance;
     public final WorldGenContext worldGenContext; // Paper - public
@@ -237,6 +_,7 @@
         );
         this.setServerViewDistance(serverViewDistance);
         this.worldGenContext = new WorldGenContext(level, generator, structureManager, this.lightEngine, null, this::setChunkUnsaved); // Paper - rewrite chunk system
+        this.entityMap = new ConcurrentRegionizedEntityMap(level); // Canvas - Threaded Regions
     }
 
     private void setChunkUnsaved(ChunkPos chunkPos) {
@@ -251,14 +_,19 @@
 
         final int index = entity.getType().getCategory().ordinal();
         final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> inRange =
-            this.level.moonrise$getNearbyPlayers().getPlayers(entity.chunkPosition(), ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
+            // Note: we can use normal getNearbyPlayers because we are ensured regionized because we use getRegionizedTickDat
+            ServerRegions.getRegionizedTickData(entity.chunkPosition().x, entity.chunkPosition().z, this.level).getNearbyPlayers().getPlayers(entity.chunkPosition(), ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE); // Canvas - Threaded Regions
         if (inRange == null) {
             return;
         }
 
         final ServerPlayer[] backingSet = inRange.getRawDataUnchecked();
         for (int i = 0, len = inRange.size(); i < len; i++) {
-            ++(backingSet[i].mobCounts[index]);
+            // Canvas start - caution ref lists
+            ServerPlayer player = backingSet[i];
+            if (player == null) continue;
+            ++(player.mobCounts[index]);
+            // Canvas end
         }
     }
 
@@ -269,13 +_,17 @@
         }
         int idx = mobCategory.ordinal();
         final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> inRange =
-            this.level.moonrise$getNearbyPlayers().getPlayersByChunk(chunkX, chunkZ, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
+            this.level.moonrise$getNearbyPlayers(new ChunkPos(chunkX, chunkZ)).getPlayersByChunk(chunkX, chunkZ, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE); // Canvas - Threaded Regions
         if (inRange == null) {
             return;
         }
         final ServerPlayer[] backingSet = inRange.getRawDataUnchecked();
         for (int i = 0, len = inRange.size(); i < len; i++) {
-            ++(backingSet[i].mobBackoffCounts[idx]);
+            // Canvas start - caution ref lists
+            ServerPlayer player = backingSet[i];
+            if (player == null) continue;
+            ++(player.mobBackoffCounts[idx]);
+            // Canvas end
         }
     }
     // Paper end - per player mob count backoff
@@ -309,7 +_,7 @@
     }
 
     @Nullable
-    protected ChunkHolder getUpdatingChunkIfPresent(long chunkPos) {
+    public ChunkHolder getUpdatingChunkIfPresent(long chunkPos) { // Canvas - protected -> public
         // Paper start - rewrite chunk system
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
         return holder == null ? null : holder.vanillaChunkHolder;
@@ -408,16 +_,11 @@
         // Paper end - rewrite chunk system
     }
 
-    protected void tick(BooleanSupplier hasMoreTime) {
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("poi");
+    public void tick(BooleanSupplier hasMoreTime) { // Canvas - protected -> public
         this.poiManager.tick(hasMoreTime);
-        profilerFiller.popPush("chunk_unload");
         if (!this.level.noSave()) {
             this.processUnloads(hasMoreTime);
         }
-
-        profilerFiller.pop();
     }
 
     public boolean hasWork() {
@@ -689,58 +_,25 @@
 
     // Paper start - optimise chunk tick iteration
     private boolean isChunkNearPlayer(final ChunkMap chunkMap, final ChunkPos chunkPos, final LevelChunk levelChunk) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData = ((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemLevelChunk)levelChunk).moonrise$getChunkHolder().holderData;
-        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk nearbyPlayers = chunkData.nearbyPlayers;
-        if (nearbyPlayers == null) {
-            return false;
-        }
-
-        // Note: cannot use narrow on Paper due to custom spawn range
-
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = nearbyPlayers.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
-
-        if (players == null) {
-            return false;
-        }
-
-        final ServerPlayer[] raw = players.getRawDataUnchecked();
-        final int len = players.size();
-
-        Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
-            // Paper start - PlayerNaturallySpawnCreaturesEvent
-            com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = raw[i].playerNaturallySpawnedEvent;
-            if (event == null || event.isCancelled()) {
-                continue;
-            }
-            double blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
-            if (chunkMap.playerIsCloseEnoughForSpawning(raw[i], chunkPos, blockRange)) {
-                // Paper end - PlayerNaturallySpawnCreaturesEvent
-                return true;
-            }
-        }
-
-        return false;
+        // Canvas start
+        ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk nearbyPlayers =
+            (levelChunk).chunkAndHolder.holderData.nearbyPlayers;
+        if (nearbyPlayers == null) return false;
+        ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> list = nearbyPlayers.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
+        return list != null &&
+            !list.isEmpty();
+        // Canvas end
     }
     // Paper end - optimise chunk tick iteration
 
-    void collectSpawningChunks(List<LevelChunk> output) {
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> tickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickServerLevel)this.level).moonrise$getPlayerTickingChunks();
-
-        final LevelChunk[] raw = tickingChunks.getRawDataUnchecked();
-        final int size = tickingChunks.size();
-
-        Objects.checkFromToIndex(0, size, raw.length);
-        for (int i = 0; i < size; ++i) {
-            final LevelChunk levelChunk = raw[i];
-
-            if (!this.isChunkNearPlayer((ChunkMap)(Object)this, levelChunk.getPos(), levelChunk)) {
-                continue;
-            }
-
-            output.add(levelChunk);
-        }
+    // Canvas start - optimize chunk collect
+    // Note: return value can have null entries.
+    LevelChunk[] collectSpawningChunks(ServerRegions.WorldTickData tickData) {
+        final LevelChunk[] raw = tickData.getEntityTickingChunks().getRawDataUnchecked();
+        ServerRegions.getTickData(this.level).lastTickingChunksCount = raw.length;
+        return raw;
     }
+    // Canvas end
 
     void forEachBlockTickingChunk(Consumer<LevelChunk> action) {
         this.distanceManager.forEachEntityTickingChunk(chunkPos -> {
@@ -774,40 +_,20 @@
         double blockRange; // Paper - use from event
         // Spigot end
         // Paper start - chunk tick iteration optimisation
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getNearbyPlayers().getPlayers(
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = (this.level).moonrise$getNearbyPlayers(chunkPos).getPlayers( // Canvas - Threaded Regions
             chunkPos, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE
         );
         if (players == null) {
             return false;
         }
 
-        final ServerPlayer[] raw = players.getRawDataUnchecked();
-        final int len = players.size();
-
-        Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
-            final ServerPlayer serverPlayer = raw[i];
-            // Paper start - PlayerNaturallySpawnCreaturesEvent
-            com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
-            blockRange = 16384.0D;
-            if (reducedRange) {
-                event = serverPlayer.playerNaturallySpawnedEvent;
-                if (event == null || event.isCancelled()) continue;
-                blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
-            }
-            if (this.playerIsCloseEnoughForSpawning(serverPlayer, chunkPos, blockRange)) {
-                // Paper end - PlayerNaturallySpawnCreaturesEvent
-                return true;
-            }
-        }
-
-        return false;
+        return !players.isEmpty(); // Canvas - optimize isChunkNearPlayer checks
         // Paper end - chunk tick iteration optimisation
     }
 
     public List<ServerPlayer> getPlayersCloseForSpawning(ChunkPos chunkPos) {
         // Paper start - chunk tick iteration optimisation
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getNearbyPlayers().getPlayers(
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = (this.level).moonrise$getNearbyPlayers(chunkPos).getPlayers( // Canvas - Threaded Regions
             chunkPos, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE
         );
         if (players == null) {
@@ -819,10 +_,11 @@
         final ServerPlayer[] raw = players.getRawDataUnchecked();
         final int len = players.size();
 
-        Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
+        // Objects.checkFromIndexSize(0, len, raw.length); // Canvas - why do we do this??
+        for (int i = 0; i < raw.length; ++i) { // Canvas
             final ServerPlayer player = raw[i];
-            if (this.playerIsCloseEnoughForSpawning(player, chunkPos, 16384.0D)) { // Spigot
+            if (player == null) continue; // Canvas - caution ref lists
+            if (this.playerIsCloseEnoughForSpawning(player, chunkPos, (Config.INSTANCE.tickDistanceMaps.playerNearChunkDetectionRange^2))) { // Spigot // Canvas
                 if (ret == null) {
                     ret = new ArrayList<>(len - i);
                     ret.add(player);
@@ -859,12 +_,12 @@
 
     void updatePlayerStatus(ServerPlayer player, boolean track) {
         boolean flag = this.skipPlayer(player);
-        boolean flag1 = this.playerMap.ignoredOrUnknown(player);
+        // boolean flag1 = this.playerMap.ignoredOrUnknown(player); // Canvas - Threaded Regions
         if (track) {
-            this.playerMap.addPlayer(player, flag);
+            // this.playerMap.addPlayer(player, flag); // Canvas - Threaded Regions
             this.updatePlayerPos(player);
             if (!flag) {
-                this.distanceManager.addPlayer(SectionPos.of(player), player);
+                // this.distanceManager.addPlayer(SectionPos.of(player), player); // Canvas - Threaded Regions
                 ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$addPlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
             }
 
@@ -872,9 +_,9 @@
             ca.spottedleaf.moonrise.common.PlatformHooks.get().addPlayerToDistanceMaps(this.level, player); // Paper - rewrite chunk system
         } else {
             SectionPos lastSectionPos = player.getLastSectionPos();
-            this.playerMap.removePlayer(player);
-            if (!flag1) {
-                this.distanceManager.removePlayer(lastSectionPos, player);
+            // this.playerMap.removePlayer(player); // Canvas - Threaded Regions
+            if (true) { // Canvas - Threaded Regions
+                // this.distanceManager.removePlayer(lastSectionPos, player); // Canvas - Threaded Regions
                 ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$removePlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
             }
 
@@ -892,27 +_,13 @@
 
         SectionPos lastSectionPos = player.getLastSectionPos();
         SectionPos sectionPos = SectionPos.of(player);
-        boolean flag = this.playerMap.ignored(player);
+        // boolean flag = this.playerMap.ignored(player); // Canvas - Threaded Regions
         boolean flag1 = this.skipPlayer(player);
-        boolean flag2 = lastSectionPos.asLong() != sectionPos.asLong();
-        if (flag2 || flag != flag1) {
+        // boolean flag2 = lastSectionPos.asLong() != sectionPos.asLong(); // Canvas - Threaded Regions
+        if (true) { // Canvas - Threaded Regions
             this.updatePlayerPos(player);
-            ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$updatePlayer(player, lastSectionPos, sectionPos, flag, flag1); // Paper - chunk tick iteration optimisation
-            if (!flag) {
-                this.distanceManager.removePlayer(lastSectionPos, player);
-            }
-
-            if (!flag1) {
-                this.distanceManager.addPlayer(sectionPos, player);
-            }
-
-            if (!flag && flag1) {
-                this.playerMap.ignorePlayer(player);
-            }
-
-            if (flag && !flag1) {
-                this.playerMap.unIgnorePlayer(player);
-            }
+            ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$updatePlayer(player, lastSectionPos, sectionPos, false, flag1); // Paper - chunk tick iteration optimisation // Canvas - Threaded Regions
+            // Canvas - Threaded Regions
 
             // Paper - rewrite chunk system
         }
@@ -942,9 +_,9 @@
     public void addEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
-        if (!entity.valid || entity.level() != this.level || this.entityMap.containsKey(entity.getId())) {
+        if (!entity.valid || entity.level() != this.level || entity.moonrise$getTrackedEntity() != null) { // Canvas - Threaded Regions
             LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName()
-                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
+                + ": " + entity  + (entity.moonrise$getTrackedEntity() != null ? " ALREADY CONTAINED (This would have crashed your server)" : entity.level() != this.level ? " NOT CORRECT LEVEL" : !entity.valid ? " NOT VALID" : ""), new Throwable()); // Canvas - be more specific - Threaded Regions
             return;
         }
         // Paper end - ignore and warn about illegal addEntity calls instead of crashing server
@@ -955,22 +_,28 @@
             i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
             if (i != 0) {
                 int updateInterval = type.updateInterval();
-                if (this.entityMap.containsKey(entity.getId())) {
+                if (entity.moonrise$getTrackedEntity() != null) { // Canvas - Threaded Regions
                     throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Entity is already tracked!"));
                 } else {
                     ChunkMap.TrackedEntity trackedEntity = new ChunkMap.TrackedEntity(entity, i, updateInterval, type.trackDeltas());
-                    this.entityMap.put(entity.getId(), trackedEntity);
+                    // this.entityMap.put(entity.getId(), trackedEntity); // Canvas - Threaded Regions
                     // Paper start - optimise entity tracker
                     if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity() != null) {
                         throw new IllegalStateException("Entity is already tracked");
                     }
                     ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$setTrackedEntity(trackedEntity);
                     // Paper end - optimise entity tracker
-                    trackedEntity.updatePlayers(this.level.players());
+                    trackedEntity.updatePlayers(this.level.getLocalPlayers(entity.chunkPosition())); // Canvas - Threaded Regions
                     if (entity instanceof ServerPlayer serverPlayer) {
                         this.updatePlayerStatus(serverPlayer, true);
 
-                        for (ChunkMap.TrackedEntity trackedEntity1 : this.entityMap.values()) {
+                        // Canvas start - Threaded Regions
+                        for (Entity possible : ServerRegions.getTickData(this.level).getTrackerEntities(entity.chunkPosition())) {
+                            ChunkMap.TrackedEntity trackedEntity1 = possible.moonrise$getTrackedEntity();
+                            if (trackedEntity1 == null) {
+                                continue;
+                            }
+                        // Canvas end
                             if (trackedEntity1.entity != serverPlayer) {
                                 trackedEntity1.updatePlayer(serverPlayer);
                             }
@@ -986,12 +_,18 @@
         if (entity instanceof ServerPlayer serverPlayer) {
             this.updatePlayerStatus(serverPlayer, false);
 
-            for (ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
+            // Canvas start - Threaded Regions
+            for (Entity possible : ServerRegions.getTickData(this.level).getLocalEntities(entity.chunkPosition())) {
+                ChunkMap.TrackedEntity trackedEntity = possible.moonrise$getTrackedEntity();
+                if (trackedEntity == null) {
+                    continue;
+                }
+            // Canvas end
                 trackedEntity.removePlayer(serverPlayer);
             }
         }
 
-        ChunkMap.TrackedEntity trackedEntity1 = this.entityMap.remove(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity1 = entity.moonrise$getTrackedEntity(); // Canvas - Threaded Regions
         if (trackedEntity1 != null) {
             trackedEntity1.broadcastRemoved();
         }
@@ -1002,31 +_,43 @@
     private void newTrackerTick() {
         final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
 
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = entityLookup.trackerEntities;
+        ServerRegions.WorldTickData data = ServerRegions.getTickData(this.level); // Canvas - Threaded Regions
+        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = this.level.moonrise$getNearbyPlayers(); // Canvas - Threaded Regions
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = data.trackerEntities; // Canvas - Threaded Regions
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
+            if (entity == null) continue; // Canvas - caution ref lists
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkData().nearbyPlayers);
+            ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity cse =  ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity);
+            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(nearbyPlayers.getChunk(entity.chunkPosition())); // Canvas - Threaded Regions
+            @Nullable FullChunkStatus chunkStatus = ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus(); // Canvas
             if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$hasPlayers()
-                || ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus().isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+                || (chunkStatus == null || chunkStatus.isOrAfter(FullChunkStatus.ENTITY_TICKING))) { // Canvas
                 tracker.serverEntity.sendChanges();
             }
         }
     }
     // Paper end - optimise entity tracker
 
-    protected void tick() {
+    public void tick() { // Canvas - protected -> public
+        // Canvas start - threaded tracker
+        if (io.canvasmc.canvas.Config.INSTANCE.entities.entityTracking.enabled) {
+            final ServerLevel level = this.level;
+            io.canvasmc.canvas.entity.MultithreadedTracker.tick(level);
+            return;
+        }
+        // Canvas end - threaded tracker
         // Paper start - optimise entity tracker
         if (true) {
             this.newTrackerTick();
             return;
         }
         // Paper end - optimise entity tracker
-        // Paper - rewrite chunk system
+        /* // Paper - rewrite chunk system // Canvas - Threaded Regions
 
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
@@ -1054,18 +_,18 @@
             for (ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
                 trackedEntity.updatePlayers(list);
             }
-        }
+        } */ // Canvas - Threaded Regions
     }
 
     public void broadcast(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity = entity.moonrise$getTrackedEntity(); // Canvas - Threaded Regions
         if (trackedEntity != null) {
             trackedEntity.broadcast(packet);
         }
     }
 
     protected void broadcastAndSend(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity = entity.moonrise$getTrackedEntity(); // Canvas - Threaded Regions
         if (trackedEntity != null) {
             trackedEntity.broadcastAndSend(packet);
         }
@@ -1139,10 +_,45 @@
 
     public class TrackedEntity implements ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity { // Paper - optimise entity tracker
         public final ServerEntity serverEntity;
-        final Entity entity;
+        public final Entity entity; // Canvas - public
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        // Canvas start - threaded tracker
+        public static final ServerPlayerConnection[] EMPTY_OBJECT_ARRAY = new ServerPlayerConnection[0];
+        private final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ServerPlayerConnection> nonSyncSeenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>() {
+            @Override
+            public boolean add(ServerPlayerConnection serverPlayerConnection) {
+                seenByUpdated = true;
+                return super.add(serverPlayerConnection);
+            }
+
+            @Override
+            public boolean remove(Object k) {
+                seenByUpdated = true;
+                return super.remove(k);
+            }
+
+            @Override
+            public void clear() {
+                seenByUpdated = true;
+                super.clear();
+            }
+        };
+        public final Set<ServerPlayerConnection> seenBy = io.canvasmc.canvas.Config.INSTANCE.entities.entityTracking.enabled ? it.unimi.dsi.fastutil.objects.ReferenceSets.synchronize(nonSyncSeenBy) : nonSyncSeenBy; // Paper - Perf: optimise map impl
+        private volatile boolean seenByUpdated = true;
+        private volatile ServerPlayerConnection[] seenByArray = EMPTY_OBJECT_ARRAY;
+        public ServerPlayerConnection[] seenBy() {
+            if (!seenByUpdated) {
+                return seenByArray;
+            } else {
+                return seenBy.toArray(EMPTY_OBJECT_ARRAY);
+            }
+        }
+        public void seenByUpdated() {
+            this.seenByArray = this.seenBy.toArray(EMPTY_OBJECT_ARRAY);
+            seenByUpdated = false;
+        }
+        // Canvas end - threaded tracker
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1169,28 +_,97 @@
             this.lastTrackedChunk = chunk;
 
             final ServerPlayer[] playersRaw = players.getRawDataUnchecked();
-
-            for (int i = 0, len = players.size(); i < len; ++i) {
+            final int playersLength = Math.min(playersRaw.length, players.size()); // Canvas - threaded tracker
+            for (int i = 0; i < playersLength; ++i) { // Canvas - threaded tracker
                 final ServerPlayer player = playersRaw[i];
+                if (player == null) continue; // Canvas - caution ref lists
                 this.updatePlayer(player);
             }
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                // Canvas start - threaded tracker
+                boolean removed = false;
+                for (final ServerPlayerConnection conn : this.seenBy()) {
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
-                        this.removePlayer(player);
-                    }
-                }
-            }
-        }
+                        removed |= this.removePlayerMulti(player);
+                    }
+                }
+                if (removed) {
+                    this.seenByUpdated();
+                }
+            }
+        }
+        // Canvas end - threaded tracker
+
+        // Canvas start - threaded tracker
+        public final @Nullable Runnable leafTickCompact(final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk chunk) {
+            if (chunk == null) {
+                this.moonrise$clearPlayers();
+                return null;
+            }
+
+            final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = chunk.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.VIEW_DISTANCE);
+
+            if (players == null) {
+                this.moonrise$clearPlayers();
+                return null;
+            }
+
+            final long lastChunkUpdate = this.lastChunkUpdate;
+            final long currChunkUpdate = chunk.getUpdateCount();
+            final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk lastTrackedChunk = this.lastTrackedChunk;
+            this.lastChunkUpdate = currChunkUpdate;
+            this.lastTrackedChunk = chunk;
+
+            final ServerPlayer[] playersRaw = players.getRawDataUnchecked();
+            final int playersLen = players.size(); // Ensure length won't change in the future tasks
+
+            if (!io.canvasmc.canvas.Config.INSTANCE.entities.entityTracking.enabled || !io.canvasmc.canvas.Config.INSTANCE.entities.entityTracking.compatModeEnabled) {
+                throw new IllegalStateException();
+            }
+            final boolean isServerPlayer = this.entity instanceof ServerPlayer;
+            final boolean isRealPlayer = isServerPlayer && ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer) this.entity).moonrise$isRealPlayer();
+            Runnable updatePlayerTasks = () -> {
+                for (int i = 0; i < playersLen; ++i) {
+                    final ServerPlayer player = playersRaw[i];
+                    this.updatePlayer(player);
+                }
+
+                if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
+                    // need to purge any players possible not in the chunk list
+                    boolean removed = false;
+                    for (final ServerPlayerConnection conn : this.seenBy()) {
+                        final ServerPlayer player = conn.getPlayer();
+                        if (!players.contains(player)) {
+                            removed |= this.removePlayerMulti(player);
+                        }
+                    }
+                    if (removed) {
+                        this.seenByUpdated();
+                    }
+                }
+            };
+
+            // Only update asynchronously for real player, and sync update for fake players
+            // This can fix compatibility issue with NPC plugins using real entity type, like Citizens
+            // To prevent visible issue with player type NPCs
+            // btw, still recommend to use packet based NPC plugins, like ZNPC Plus, Adyeshach, Fancy NPC, etc.
+            if (isRealPlayer || !isServerPlayer) {
+                return updatePlayerTasks;
+            } else {
+                updatePlayerTasks.run();
+                return null;
+            }
+        }
+        // Canvas end - threaded tracker
 
         @Override
         public final void moonrise$removeNonTickThreadPlayers() {
             boolean foundToRemove = false;
-            for (final ServerPlayerConnection conn : this.seenBy) {
-                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(conn.getPlayer())) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Canvas - threaded tracker
+                if (!io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(conn.getPlayer())) { // Canvas - Threaded Regions
                     foundToRemove = true;
                     break;
                 }
@@ -1200,12 +_,13 @@
                 return;
             }
 
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Canvas - threaded tracker
                 ServerPlayer player = conn.getPlayer();
-                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
-                    this.removePlayer(player);
+                if (!io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(player)) { // Canvas - Threaded Regions
+                    this.removePlayerMulti(player); // Canvas - threaded tracker
                 }
             }
+            this.seenByUpdated(); // Canvas - threaded tracker
         }
 
         @Override
@@ -1215,10 +_,11 @@
             if (this.seenBy.isEmpty()) {
                 return;
             }
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Canvas - threaded tracker
                 ServerPlayer player = conn.getPlayer();
-                this.removePlayer(player);
+                this.removePlayerMulti(player); // Canvas - threaded tracker
             }
+            this.seenByUpdated(); // Canvas - threaded tracker
         }
 
         @Override
@@ -1245,7 +_,7 @@
         }
 
         public void broadcast(Packet<?> packet) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Canvas - threaded tracker
                 serverPlayerConnection.send(packet);
             }
         }
@@ -1266,21 +_,34 @@
         }
 
         public void broadcastRemoved() {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Canvas - threaded tracker
                 this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
             }
         }
 
+        // Canvas start - threaded tracker
+        public boolean removePlayerMulti(ServerPlayer player) {
+            if (this.seenBy.remove(player.connection)) {
+                this.serverEntity.removePairing(player);
+                return true;
+            } else {
+                return false;
+            }
+        }
+        // Canvas end - threaded tracker
+
         public void removePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
+            this.seenByUpdated(); // Canvas - threaded tracker
         }
 
         public void updatePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (player != this.entity) {
+                if (player == null) return; // Canvas - threaded tracker
                 // Paper start - remove allocation of Vec3D here
                 // Vec3 vec3 = player.position().subtract(this.entity.position());
                 double vec3_dx = player.getX() - this.entity.getX();
@@ -1302,12 +_,13 @@
                 flag = flag && this.entity.broadcastToPlayer(player) && ChunkMap.this.isChunkTracked(player, this.entity.chunkPosition().x, this.entity.chunkPosition().z);
                 // Paper end - Configurable entity tracking range by Y
                 // CraftBukkit start - respect vanish API
-                if (flag && !player.getBukkitEntity().canSee(this.entity.getBukkitEntity())) { // Paper - only consider hits
+                if (flag && !player.getBukkitEntity().canSeeChunkMapUpdatePlayer(this.entity.getBukkitEntity())) { // Paper - only consider hits // Canvas - optimize canSee checks
                     flag = false;
                 }
                 // CraftBukkit end
                 if (flag) {
                     if (this.seenBy.add(player.connection)) {
+                        this.seenByUpdated(); // Canvas - threaded tracker
                         // Paper start - entity tracking events
                         if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
                         this.serverEntity.addPairing(player);
@@ -1316,6 +_,7 @@
                         this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
                     }
                 } else if (this.seenBy.remove(player.connection)) {
+                    this.seenByUpdated(); // Canvas - threaded tracker
                     this.serverEntity.removePairing(player);
                 }
             }
