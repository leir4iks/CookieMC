--- a/net/minecraft/server/level/ServerEntity.java
+++ b/net/minecraft/server/level/ServerEntity.java
@@ -14,6 +_,7 @@
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.Config;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
@@ -118,7 +_,19 @@
         // Paper end - optimise collisions
         List<Entity> passengers = this.entity.getPassengers();
         if (!passengers.equals(this.lastPassengers)) {
-            List<UUID> list = this.mountedOrDismounted(passengers).map(Entity::getUUID).toList();
+            // Canvas start - remove streams
+            List<UUID> list = new ArrayList<>();
+            for (Entity entity : this.lastPassengers) {
+                if (!passengers.contains(entity)) {
+                    list.add(entity.getUUID());
+                }
+            }
+            for (Entity entity : passengers) {
+                if (!this.lastPassengers.contains(entity)) {
+                    list.add(entity.getUUID());
+                }
+            }
+            // Canvas end
             this.broadcastWithIgnore.accept(new ClientboundSetPassengersPacket(this.entity), list);
             // Paper start - Allow riding players
             if (this.entity instanceof ServerPlayer player) {
@@ -189,22 +_,45 @@
                     packet = ClientboundEntityPositionSyncPacket.of(this.entity);
                     flag3 = true;
                     flag4 = true;
-                } else if ((!flag2 || !flag) && !(this.entity instanceof AbstractArrow)) {
-                    if (flag2) {
-                        packet = new ClientboundMoveEntityPacket.Pos(this.entity.getId(), (short)l, (short)l1, (short)l2, this.entity.onGround());
-                        flag3 = true;
-                    } else if (flag) {
-                        packet = new ClientboundMoveEntityPacket.Rot(this.entity.getId(), b, b1, this.entity.onGround());
-                        flag4 = true;
-                    }
+                // Canvas start - better checking for useless move packets
                 } else {
-                    packet = new ClientboundMoveEntityPacket.PosRot(this.entity.getId(), (short)l, (short)l1, (short)l2, b, b1, this.entity.onGround());
-                    flag3 = true;
-                    flag4 = true;
+                    if (flag2 || flag || this.entity instanceof AbstractArrow) {
+                        if ((!flag2 || !flag) && !(this.entity instanceof AbstractArrow)) {
+                            if (flag2) {
+                                packet = new ClientboundMoveEntityPacket.Pos(this.entity.getId(), (short) l, (short) l1, (short) l2, this.entity.onGround());
+                                flag3 = true;
+                            } else if (flag) {
+                                packet = new ClientboundMoveEntityPacket.Rot(this.entity.getId(), b, b1, this.entity.onGround());
+                                flag4 = true;
+                            }
+                        } else {
+                            packet = new ClientboundMoveEntityPacket.PosRot(this.entity.getId(), (short) l, (short) l1, (short) l2, b, b1, this.entity.onGround());
+                            flag3 = true;
+                            flag4 = true;
+                        }
+                    }
                 }
+                // Canvas end - better checking for useless move packets
 
+                // Canvas start - reduce useless entity move packets
+                if (Config.INSTANCE.entities.reduceUselessEntityMovePackets && packet != null) {
+                    boolean isUseless = packet instanceof ClientboundMoveEntityPacket moveEntityPacket && switch (packet) {
+                        case ClientboundMoveEntityPacket.Pos ignored ->
+                            moveEntityPacket.getXa() == 0 && moveEntityPacket.getYa() == 0 && moveEntityPacket.getZa() == 0;
+                        case ClientboundMoveEntityPacket.PosRot ignored ->
+                            moveEntityPacket.getXa() == 0 && moveEntityPacket.getYa() == 0 && moveEntityPacket.getZa() == 0 && moveEntityPacket.getYRot() == 0 && moveEntityPacket.getXRot() == 0;
+                        case ClientboundMoveEntityPacket.Rot ignored ->
+                            moveEntityPacket.getYRot() == 0 && moveEntityPacket.getXRot() == 0;
+                        default -> false;
+                    };
+                    if (isUseless) {
+                        packet = null;
+                    }
+                }
+                // Canvas end
                 if (this.entity.hasImpulse || this.trackDelta || this.entity instanceof LivingEntity && ((LivingEntity)this.entity).isFallFlying()) {
                     Vec3 deltaMovement = this.entity.getDeltaMovement();
+                    if (deltaMovement != this.lastSentMovement) { // Canvas - skip distanceToSqr if delta movement hasn't changed
                     double d = deltaMovement.distanceToSqr(this.lastSentMovement);
                     if (d > 1.0E-7 || d > 0.0 && deltaMovement.lengthSqr() == 0.0) {
                         this.lastSentMovement = deltaMovement;
@@ -222,6 +_,7 @@
                             this.broadcast.accept(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement));
                         }
                     }
+                    } // Canvas - skip distanceToSqr if delta movement hasn't changed
                 }
 
                 if (packet != null) {
@@ -431,7 +_,7 @@
                 this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), attributesToSync));
             }
 
-            attributesToSync.clear();
+            // attributesToSync.clear(); // Canvas - threaded tracker
         }
     }
 
