--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -1,5 +_,7 @@
 package net.minecraft.server.level;
 
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
@@ -103,8 +_,6 @@
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.Unit;
-import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.Container;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.InteractionHand;
@@ -188,7 +_,10 @@
 
 public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer { // Paper - rewrite chunk system
     private static final Logger LOGGER = LogUtils.getLogger();
-    public long lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
+    // Canvas start - Threaded Regions
+    public static final long LAST_SAVE_ABSENT = Long.MIN_VALUE;
+    public long lastSave = LAST_SAVE_ABSENT; // Paper - Incremental chunk and player saving
+    // Canvas end
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
     private static final int FLY_STAT_RECORDING_SPEED = 25;
@@ -424,6 +_,7 @@
     private boolean tpsBar = false; // Purpur - Implement TPSBar
     private boolean compassBar = false; // Purpur - Add compass command
     private boolean ramBar = false; // Purpur - Implement rambar commands
+    public volatile boolean requestingTimeResync = false; // Canvas - Threaded Dimensions
 
     // Paper start - rewrite chunk system
     private ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.PlayerChunkLoaderData chunkLoader;
@@ -493,7 +_,7 @@
             long l1 = l * l;
             int i = l1 > 2147483647L ? Integer.MAX_VALUE : (int)l1;
             int coprime = this.getCoprime(i);
-            int randomInt = RandomSource.create().nextInt(i);
+            int randomInt = level.random.nextInt(i); // Canvas - reduce RandomSource instances
 
             for (int i1 = 0; i1 < i; i1++) {
                 int i2 = (randomInt + coprime * i1) % i;
@@ -772,12 +_,24 @@
 
         Entity camera = this.getCamera();
         if (camera != this) {
-            if (camera.isAlive()) {
+            if (camera.canBeSpectated()) { // Canvas - Threaded Regions - replace removed check
+                if (io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(camera) && !camera.isRemoved()) { // Canvas - Threaded Regions
                 this.absSnapTo(camera.getX(), camera.getY(), camera.getZ(), camera.getYRot(), camera.getXRot());
                 this.serverLevel().getChunkSource().move(this);
                 if (this.wantsToStopRiding()) {
                     this.setCamera(this);
                 }
+                // Canvas start - Threaded Regions
+                } else {
+                    Entity realCamera = camera.getBukkitEntity().getHandleRaw();
+                    if (realCamera != camera) {
+                        this.setCamera(this);
+                        this.setCamera(realCamera);
+                    } else {
+                        this.teleportToCameraOffRegion();
+                    }
+                }
+                // Canvas end
             } else {
                 this.setCamera(this);
             }
@@ -802,22 +_,25 @@
         }
         // Purpur end - Ridables
     }
+    // Canvas start - Threaded Regions
+    private void teleportToCameraOffRegion() {
+        final Entity camera = this.getCamera();
+        if (this == camera || camera.isRemoved()) {
+            return;
+        }
+
+        ServerRegions.teleportAsync(
+            this, (ServerLevel) camera.level(), camera.getX(), camera.getY(), camera.getZ(),
+            camera.getYRot(), camera.getXRot(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE
+        ).exceptionally(error -> {
+            LOGGER.error("Failed to teleport player {} to spectate camera {}", this.getScoreboardName(), camera.getScoreboardName(), error);
+            this.server.execute(() -> {
+                if (this.getCamera() == camera) {
+                    this.setCamera(this);
+                }
+            });
+            return null;
+        });
+    }
+    // Canvas end
 
     private void updatePlayerAttributes() {
         AttributeInstance attribute = this.getAttribute(Attributes.BLOCK_INTERACTION_RANGE);
@@ -826,15 +_,22 @@
 
     @Override
     public void doTick() {
-        try {
+        try { // Paper - fix compile
             if (valid && !this.isSpectator() || !this.touchingUnloadedChunk()) { // Paper - don't tick dead players that are not in the world currently (pending respawn)
-                super.tick();
+                if (!this.touchingUnloadedChunk()) super.tick(); // Canvas - ensure we dont touch any unloaded chunk
             }
 
+            // Canvas start - only tick items in hand
+            if (Config.INSTANCE.entities.onlyTickItemsInHand) {
+                this.synchronizeSpecialItemUpdates(this.getMainHandItem());
+                this.synchronizeSpecialItemUpdates(this.getOffhandItem());
+            } else {
+            // Canvas end
             for (int i = 0; i < this.getInventory().getContainerSize(); i++) {
                 ItemStack item = this.getInventory().getItem(i);
                 if (!item.isEmpty()) {
                     this.synchronizeSpecialItemUpdates(item);
                 }
             }
+            } // Canvas - only tick items in hand
 
             if (this.getHealth() != this.lastSentHealth
                 || this.lastSentFood != this.foodData.getFoodLevel()
@@ -905,7 +_,7 @@
             }
             // CraftBukkit end
         } catch (Throwable var4) {
+            var4.printStackTrace(); // Canvas - print please.
             CrashReport crashReport = CrashReport.forThrowable(var4, "Ticking player");
             CrashReportCategory crashReportCategory = crashReport.addCategory("Player being ticked");
             this.fillCrashReportCategory(crashReportCategory);
@@ -1030,6 +_,7 @@
     // Paper end - Expand PlayerDeathEvent API
     @Override
     public void die(DamageSource cause) {
+        processingDeath = true; // Canvas - item entity spread
         // this.gameEvent(GameEvent.ENTITY_DIE); // Paper - move below event cancellation check
         boolean _boolean = this.serverLevel().getGameRules().getBoolean(GameRules.RULE_SHOWDEATHMESSAGES); final boolean showDeathMessage = _boolean; // Paper - OBFHELPER
         // CraftBukkit start - fire PlayerDeathEvent
@@ -1146,6 +_,7 @@
         this.getCombatTracker().recheckStatus();
         this.setLastDeathLocation(Optional.of(GlobalPos.of(this.level().dimension(), this.blockPosition())));
         this.setClientLoaded(false);
+        processingDeath = false; // Canvas
     }
 
     private void tellNeutralMobsThatIDied() {
@@ -1408,14 +_,10 @@
                 this.unsetRemoved();
                 */
                 // CraftBukkit end
-                ProfilerFiller profilerFiller = Profiler.get();
-                profilerFiller.push("moving");
                 if (level != null && resourceKey == net.minecraft.world.level.dimension.LevelStem.OVERWORLD && level.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER) { // CraftBukkit - empty to fall through to null to event
                     this.enteredNetherPosition = this.position();
                 }
 
-                profilerFiller.pop();
-                profilerFiller.push("placing");
                 // CraftBukkit start
                 this.isChangingDimension = true; // CraftBukkit - Set teleport invulnerability only if player changing worlds
                 LevelData worlddata = level.getLevelData();
@@ -1433,7 +_,6 @@
                 this.connection.internalTeleport(PositionMoveRotation.of(teleportTransition), teleportTransition.relatives()); // CraftBukkit - use internal teleport without event
                 this.connection.resetPosition();
                 level.addDuringTeleport(this);
-                profilerFiller.pop();
                 this.triggerDimensionChangeTriggers(serverLevel);
                 this.stopUsingItem();
                 this.connection.send(new ClientboundPlayerAbilitiesPacket(this.getAbilities()));
@@ -1520,6 +_,13 @@
         super.take(entity, quantity);
         this.containerMenu.broadcastChanges();
     }
+    // Canvas start - cache eligible players for despawn checks
+
+    @Override
+    public boolean isAlive() {
+        return !this.isRemoved() && this.entityData.get(DATA_HEALTH_ID) > 0.0f && !this.dead;
+    }
+    // Canvas end
 
     // CraftBukkit start - moved bed result checks from below into separate method
     private Either<Player.BedSleepingProblem, Unit> getBedResult(BlockPos at, Direction direction) {
@@ -2152,12 +_,18 @@
 
     @Override
     public void crit(Entity entityHit) {
-        this.serverLevel().getChunkSource().broadcastAndSend(this, new ClientboundAnimatePacket(entityHit, 4));
+        // Canvas start - broadcast crit animations as the entity being critted
+        var level = this.serverLevel();
+        level.getChunkSource().broadcastAndSend(Config.INSTANCE.fixes.broadcastCritAnimationsAsTheEntityBeingCritted ? entityHit : this, new ClientboundAnimatePacket(entityHit, 4));
+        // Canvas end
     }
 
     @Override
     public void magicCrit(Entity entityHit) {
-        this.serverLevel().getChunkSource().broadcastAndSend(this, new ClientboundAnimatePacket(entityHit, 5));
+        // Canvas start - broadcast crit animations as the entity being critted
+        var level = this.serverLevel();
+        level.getChunkSource().broadcastAndSend(Config.INSTANCE.fixes.broadcastCritAnimationsAsTheEntityBeingCritted ? entityHit : this, new ClientboundAnimatePacket(entityHit, 5));
+        // Canvas end
     }
 
     @Override
@@ -2188,6 +_,7 @@
             this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.CHANGE_GAME_MODE, gameMode.getId()));
             if (gameMode == GameType.SPECTATOR) {
                 this.removeEntitiesOnShoulder();
+                this.stopSleeping(); // Canvas - MC-119417
                 this.stopRiding();
                 EnchantmentHelper.stopLocationBasedEffects(this);
             } else {
@@ -2464,6 +_,11 @@
     }
 
     public void setCamera(@Nullable Entity entityToSpectate) {
+        // Canvas start - Threaded Regions
+        if (entityToSpectate != null && (entityToSpectate != this && !entityToSpectate.canBeSpectated())) {
+            return;
+        }
+        // Canvas end
         Entity camera = this.getCamera();
         this.camera = (Entity)(entityToSpectate == null ? this : entityToSpectate);
         if (camera != this.camera) {
@@ -2482,19 +_,17 @@
                 }
             }
             // Paper end - Add PlayerStartSpectatingEntityEvent and PlayerStopSpectatingEntity
-            if (this.camera.level() instanceof ServerLevel serverLevel) {
-                this.teleportTo(serverLevel, this.camera.getX(), this.camera.getY(), this.camera.getZ(), Set.of(), this.getYRot(), this.getXRot(), false, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
-            }
-
-            if (entityToSpectate != null) {
-                this.serverLevel().getChunkSource().move(this);
-            }
-
+            // Canvas - Threaded Regions - move down && not needed
+
+            // Canvas start - Threaded Regions - handle camera setting better
+            if (this.camera == this
+                || (io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(this.camera) && this.camera.moonrise$getTrackedEntity() != null
+                && this.camera.moonrise$getTrackedEntity().seenBy.contains(this.connection))) {
             this.connection.send(new ClientboundSetCameraPacket(this.camera));
-            this.connection.resetPosition();
+            }
+            // this.connection.resetPosition();
+            this.teleportToCameraOffRegion();
+            // Canvas end
         }
     }
 
