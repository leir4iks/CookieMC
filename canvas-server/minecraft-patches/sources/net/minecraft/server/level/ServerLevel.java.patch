--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -5,8 +_,19 @@
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.entity.tnt.TNTMergeManager;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.RegionizedTaskQueue;
+import io.canvasmc.canvas.region.ServerRegions;
+import io.canvasmc.canvas.scheduler.TickableScheduler;
+import io.canvasmc.canvas.server.level.distance.command.DistanceUtils;
+import io.canvasmc.canvas.util.SimpleThreadLocalRandomSource;
+import io.netty.util.internal.ConcurrentSet;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntMaps;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
@@ -18,13 +_,17 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -36,26 +_,33 @@
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
+import net.minecraft.ReportedException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderSet;
+import net.minecraft.core.RegistryAccess;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundExplodePacket;
-import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -74,8 +_,6 @@
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.datafix.DataFixTypes;
-import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.DifficultyInstance;
@@ -98,10 +_,12 @@
 import net.minecraft.world.entity.animal.horse.SkeletonHorse;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
+import net.minecraft.world.entity.boss.wither.WitherBoss;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.raid.Raid;
 import net.minecraft.world.entity.raid.Raids;
 import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.alchemy.PotionBrewing;
 import net.minecraft.world.item.crafting.RecipeManager;
 import net.minecraft.world.level.BlockEventData;
@@ -119,6 +_,7 @@
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.SnowLayerBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.FuelValues;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
@@ -142,6 +_,7 @@
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
 import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.WorldOptions;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructureCheck;
@@ -164,6 +_,7 @@
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
+import org.agrona.collections.ObjectHashSet;
 import org.slf4j.Logger;
 
 public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLevel, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevelReader, ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickServerLevel { // Paper - rewrite chunk system // Paper - chunk tick iteration
@@ -175,31 +_,59 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    // Canvas start - use concurrent - add empty world sleeping
+    final List<ServerPlayer> players = new CopyOnWriteArrayList<>() {
+        @Override
+        public boolean add(final ServerPlayer player) {
+            if (ServerLevel.this.isSleeping()) {
+                ServerLevel.this.wake();
+            }
+            return super.add(player);
+        }
+    };
+    // Canvas end
     public final ServerChunkCache chunkSource;
-    private final MinecraftServer server;
+    // Canvas start - Threaded Regions
+    public final ServerRegions.TickRegions tickRegions = new ServerRegions.TickRegions();
+    public ThreadedRegionizer<ServerRegions.TickRegionData, ServerRegions.TickRegionSectionData> regioniser = new io.papermc.paper.threadedregions.ThreadedRegionizer<>(
+        (int)Math.max(1L, (8L * 16L * 16L) / (1L << (2 * (io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift())))),
+        (1.0 / 6.0),
+        Math.max(1, 8 / (1 << io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift())),
+        1,
+        io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift(),
+        this,
+        this.tickRegions
+    );
+    public final ServerRegions.WorldTickData levelTickData;
+    public final RegionizedTaskQueue.WorldRegionTaskData taskQueueRegionData = new RegionizedTaskQueue.WorldRegionTaskData(this);
+    // Note: only to be used when non-regionized.
+    public final RegionizedTaskQueue.RegionTaskQueueData regionTaskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.taskQueueRegionData);
+    // Canvas end
+    // private final MinecraftServer server; // Canvas - clashes with super
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
+    public ItemStack ominousBanner; // Canvas
+    public ChunkPos randomSpawnSelection; // Canvas
     private int lastSpawnChunkRadius;
-    final EntityTickList entityTickList = new EntityTickList();
+    // public final EntityTickList entityTickList = new EntityTickList(); // Canvas - public - Threaded Regions
     // Paper - rewrite chunk system
     private final GameEventDispatcher gameEventDispatcher;
     public boolean noSave;
     private final SleepStatus sleepStatus;
     private int emptyTime;
     private final PortalForcer portalForcer;
-    private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
-    private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
-    private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>();
-    volatile boolean isUpdatingNavigations;
+    // private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded); // Canvas - Threaded Regions
+    // private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded); // Canvas - Threaded Regions
+    // private final PathTypeCache pathTypesByPosCache = new PathTypeCache(); // Canvas - Threaded Regions
+    // final Set<Mob> navigatingMobs = Sets.newConcurrentHashSet(); // Canvas - concurrent - Threaded Regions
+    final ThreadLocal<Boolean> isUpdatingNavigations = ThreadLocal.withInitial(() -> false); // Canvas - threadlocal
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64);
-    private boolean handlingTick;
+    // private final List<BlockEventData> blockEvents = new CopyOnWriteArrayList<>(); // Canvas - copy-on-write arraylist - Threaded Regions
+    // private final Queue<BlockEventData> blockEventsToReschedule = new ConcurrentLinkedQueue<>(); // Canvas - concurrent - Threaded Regions
+    // private boolean handlingTick; // Canvas - Threaded Regions
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final Int2ObjectMap<EnderDragonPart> dragonParts = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap<>()); // Canvas - synchronize
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
@@ -297,11 +_,11 @@
     private final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler;
     private long lastMidTickFailure;
     private long tickedBlocksOrFluids;
-    private final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = new ca.spottedleaf.moonrise.common.misc.NearbyPlayers((ServerLevel)(Object)this);
+    // private final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = new ca.spottedleaf.moonrise.common.misc.NearbyPlayers((ServerLevel)(Object)this); // Canvas - Threaded Regions
     private static final LevelChunk[] EMPTY_LEVEL_CHUNKS = new LevelChunk[0];
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> loadedChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> loadedChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // Canvas - Threaded Regions
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // Canvas - Threaded Regions
+    // private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS); // Canvas - Threaded Regions
 
     @Override
     public final LevelChunk moonrise$getFullChunkIfLoaded(final int chunkX, final int chunkZ) {
@@ -329,7 +_,7 @@
 
     @Override
     public final void moonrise$midTickTasks() {
-        ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+        this.chunkSource.pollTask(); // Canvas - poll task, as executeMidTickTasks does nothing now
     }
 
     @Override
@@ -460,22 +_,28 @@
 
     @Override
     public final ca.spottedleaf.moonrise.common.misc.NearbyPlayers moonrise$getNearbyPlayers() {
-        return this.nearbyPlayers;
-    }
-
+        return ServerRegions.getTickData(this).getNearbyPlayers(); // Canvas - Threaded Regions
+    }
+
+    // Canvas start - Threaded Regions
+    public final ca.spottedleaf.moonrise.common.misc.NearbyPlayers moonrise$getNearbyPlayers(ChunkPos position) {
+        return ServerRegions.getTickData(this).getNearbyPlayers(position);
+    }
+
+    // Canvas end
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getLoadedChunks() {
-        return this.loadedChunks;
+        return ServerRegions.getTickData(this).getChunks(); // Canvas - Threaded Regions
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getTickingChunks() {
-        return this.tickingChunks;
+        return ServerRegions.getTickData(this).getTickingChunks(); // Canvas - Threaded Regions
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getEntityTickingChunks() {
-        return this.entityTickingChunks;
+        return ServerRegions.getTickData(this).getEntityTickingChunks(); // Canvas - Threaded Regions
     }
 
     @Override
@@ -495,7 +_,7 @@
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration
     private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+    private final it.unimi.dsi.fastutil.longs.Long2IntMap playerTickingRequests = Long2IntMaps.synchronize(new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap()); // Canvas - synchronized
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getPlayerTickingChunks() {
@@ -505,7 +_,7 @@
     @Override
     public final void moonrise$markChunkForPlayerTicking(final LevelChunk chunk) {
         final ChunkPos pos = chunk.getPos();
-        if (!this.playerTickingRequests.containsKey(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos))) {
+        if (!this.playerTickingRequests.containsKey(pos.longKey)) { // Canvas - cache chunk key
             return;
         }
 
@@ -523,7 +_,7 @@
 
         final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
 
-        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
+        if (this.playerTickingRequests.compute(chunkKey, (k, v) -> (v == null ? 0 : v) + 1) != 1) { // Canvas
             // already added
             return;
         }
@@ -543,7 +_,10 @@
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
 
         final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
+        // Canvas start
+        int val = this.playerTickingRequests.compute(chunkKey, (_, v) -> (v == null ? 0 : v) - 1);
+        val += 1;
+        // Canvas end
 
         if (val <= 0) {
             throw new IllegalStateException("Negative counter");
@@ -589,7 +_,7 @@
         this.uuid = org.bukkit.craftbukkit.util.WorldUUID.getOrCreate(levelStorageAccess.levelDirectory.path().toFile());
         // CraftBukkit end
         this.tickTime = tickTime;
-        this.server = server;
+        // this.server = server; // Canvas - clashes with super
         // Purpur start - Allow toggling special MobSpawners per world
         this.customSpawners = new ArrayList<>();
         if (purpurConfig.phantomSpawning) {
@@ -692,6 +_,21 @@
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.preciseTime = this.serverLevelData.getDayTime(); // Purpur - Configurable daylight cycle
+        this.ominousBanner = Objects.requireNonNullElse(this.registryAccess(), RegistryAccess.EMPTY).lookup(Registries.BANNER_PATTERN).map(Raid::getOminousBannerInstance).orElse(null); // Canvas
+        // Canvas start
+        ServerChunkCache cmgr = getChunkSource();
+
+        int viewDistance = DistanceUtils.resolveViewDistance(this);
+        cmgr.setViewDistance(viewDistance - 1);
+
+        int simulationDistance = DistanceUtils.resolveSimulationDistance(this);
+        cmgr.setSimulationDistance(simulationDistance - 1);
+
+        this.scheduleTo(MinecraftServer.getThreadedServer().scheduler.scheduler);
+        this.networkRouter = new io.canvasmc.canvas.server.NetworkRouter(this); // connection threading
+        this.levelTickData = new ServerRegions.WorldTickData(this, null); // Threaded Regions
+        this.wake();
+        // Canvas end
     }
 
     // Paper start
@@ -723,18 +_,147 @@
     public StructureManager structureManager() {
         return this.structureManager;
     }
-
-    public void tick(BooleanSupplier hasTimeLeft) {
-        ProfilerFiller profilerFiller = Profiler.get();
-        this.handlingTick = true;
+    // Canvas start - Threaded Dimensions
+
+    public final io.canvasmc.canvas.server.NetworkRouter networkRouter; // connection threading
+    private int ticksSinceLastBlockEventsTickCall = 0;
+    private int ticksSinceLastRaidTickCall = 0;
+    private int ticksSinceLastTickCustomSpawnersCall = 0;
+
+    public void tickConnection(ServerRegions.WorldTickData data) { // Canvas - protected -> public
+        // Canvas start - Threaded Regions
+        // technically connections can be sent to the level
+        // with regionizing enabled, which causes the player
+        // to just... never be ticked... ever... so we comb
+        // through ours to check if we need to push connections
+        // to the region tick data or not
+        // in MOST instances, this is very intentional for connections
+        // to be passed through here to get to the region
+        if (data.region == null) {
+            this.networkRouter.tickRouter();
+            if (this.server.isRegionized()) { // if the region in the data is null, we are running a world region, cannot do this with regionizing
+                return;
+            }
+        }
+        // Canvas end
+        if (false) for (ServerPlayer player : data.getLocalPlayers()) {
+            player.connection.suspendFlushing();
+        }
+        final List<Connection> connections = new ArrayList<>(data.connections);
+        Collections.shuffle(connections);
+        for (final Connection conn : connections) {
+            if (!conn.isConnected()) {
+                conn.handleDisconnection();
+                continue;
+            }
+            if (!data.connections.contains(conn)) {
+                // removed by connection tick?
+                continue;
+            }
+
+            try {
+                conn.tick();
+            } catch (final Exception exception) {
+                if (conn.isMemoryConnection()) {
+                    throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                }
+
+                LOGGER.warn("Failed to handle packet for {}", conn.getLoggableAddress(MinecraftServer.getServer().logIPs()), exception);
+                MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
+
+                conn.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                    conn.disconnect(ichatmutablecomponent);
+                }));
+                conn.setReadOnly();
+            }
+        }
+    }
+
+    public void syncTimeToPlayers() {
+        final boolean doDaylight = this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+        final long dayTime = this.getDayTime();
+        long worldTime = this.getGameTime();
+        final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
+        for (ServerPlayer entityhuman : this.getLocalPlayers()) {
+            if (entityhuman == null || (!entityhuman.requestingTimeResync && (ServerRegions.getCurrentTick(this) + entityhuman.getId()) % 20 != 0)) {
+                continue;
+            }
+            entityhuman.requestingTimeResync = false;
+            entityhuman.connection.send(worldPacket);
+        }
+    }
+
+    private int sendAllPlayerInfoIn;
+
+    public void tickPlayerList(ServerRegions.WorldTickData tickData) { // Canvas - Threaded Regions
+        if (++this.sendAllPlayerInfoIn > 600) {
+            List<ServerPlayer> players = tickData.getLocalPlayers(); // Canvas - Threaded Regions
+            for (int i = 0; i < players.size(); ++i) { // Canvas - Threaded Regions
+                final ServerPlayer targetPlayer = players.get(i); // Canvas - Threaded Regions
+                // Canvas start - optimize player list for sending player info
+                var target = targetPlayer.getBukkitEntity();
+                final List<ServerPlayer> list = new java.util.ArrayList<>(players.size());
+                for (ServerPlayer player : players) {
+                    if (target.canSeePlayer(player.getUUID())) {
+                        list.add(player);
+                    }
+                }
+
+                targetPlayer.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), list));
+                // Canvas end
+            }
+            this.sendAllPlayerInfoIn = 0;
+        }
+
+    }
+
+    public void regionTick1(ServerRegions.WorldTickData tickData) {
+        ((TickableScheduler) this.server.server.getRegionScheduler()).tick(tickData);
+        if (this.server.isRegionized()) this.syncTimeToPlayers();
+        for (final Entity entity : tickData.getLocalEntitiesCopy()) {
+            if (entity == null || !entity.getBukkitEntity().taskScheduler.hasTasks()) continue; // Canvas - optimize entity scheduler
+            entity.tickScheduler();
+        }
+        chunkSource.tick(() -> true, false);
+    }
+
+    public void worldtick(BooleanSupplier hasTimeLeft, int tickCount) {
+        ServerRegions.WorldTickData tickData = ServerRegions.getTickData(this); // Canvas - Threaded Regions
+        tickData.popTick();
+        this.taskQueueRegionData.drainGlobalChunkTasks(); // Canvas - Threaded Regions
+        tickData.setHandlingTick(true); // Canvas - Threaded Regions
+        // this.tickRateManager().tick(); // run on main
+        this.tickConnection(tickData); // Canvas - Threaded Regions
+
+        tickData.tpsCalculator.doTick(); // Canvas - Threaded Regions
+
+        // tick the "region" scheduler
+        // moved to region tick
+        /* ((CanvasPerWorldScheduler) this.server.server.getRegionScheduler()).tick(this);
+        for (final Entity entity : this.getEntities().getAll()) {
+            final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+            if (bukkit != null) {
+                if (entity.isRemoved()) {
+                    continue;
+                }
+                bukkit.taskScheduler.executeTick();
+            }
+        }
+        chunkSource.tick(() -> true, false); */
+        if (!this.server.isRegionized()) regionTick1(tickData); // Canvas - Threaded Regions
+
+        hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+        hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        // net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+        updateLagCompensationTick();
+        hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+    // Canvas end
+        // Canvas - Threaded Regions
         TickRateManager tickRateManager = this.tickRateManager();
         boolean runsNormally = tickRateManager.runsNormally();
         if (runsNormally) {
-            profilerFiller.push("world border");
             this.getWorldBorder().tick();
-            profilerFiller.popPush("weather");
             this.advanceWeatherCycle();
-            profilerFiller.pop();
         }
 
         int _int = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
@@ -767,53 +_,103 @@
         if (runsNormally) {
             this.tickTime();
         }
-
-        profilerFiller.push("tickPending");
+    // Canvas start - Threaded Regions
+        if (!this.server.isRegionized()) this.regionTick2(runsNormally, tickData);
+        this.worldtick2(runsNormally, hasTimeLeft, tickData);
+    }
+
+    public void regionTick2(boolean runsNormally, ServerRegions.WorldTickData tickData) {
+    // Canvas end
+
         if (!this.isDebug() && runsNormally) {
-            long l = this.getGameTime();
-            profilerFiller.push("blockTicks");
-            this.blockTicks.tick(l, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks
-            profilerFiller.popPush("fluidTicks");
-            this.fluidTicks.tick(l, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks
-            profilerFiller.pop();
+            // Canvas start - ticks_since config - Threaded Regions
+            long l = tickData.getRedstoneGameTime();
+            if (tickData.getBlockLevelTicks().ticksSinceLastBlockTickCall++ > Config.INSTANCE.ticksBetweenBlockTicking) {
+            tickData.getBlockLevelTicks().tick(l, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks
+            tickData.getBlockLevelTicks().ticksSinceLastBlockTickCall = 0;
+            }
+            if (tickData.getFluidLevelTicks().ticksSinceLastFluidTickCall++ > Config.INSTANCE.ticksBetweenFluidTicking) {
+            tickData.getFluidLevelTicks().tick(l, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks
+            tickData.getFluidLevelTicks().ticksSinceLastFluidTickCall = 0;
+            }
+            // Canvas end
         }
 
-        profilerFiller.popPush("raid");
         if (runsNormally) {
+            // Canvas start
+            if (this.ticksSinceLastRaidTickCall++ > Config.INSTANCE.ticksBetweenRaidTicking) {
             this.raids.tick(this);
+            this.ticksSinceLastRaidTickCall = 0;
+            }
+            // Canvas end
         }
 
-        profilerFiller.popPush("chunkSource");
-        this.getChunkSource().tick(hasTimeLeft, true);
-        profilerFiller.popPush("blockEvents");
-        if (runsNormally) {
+    // Canvas start - Threaded Regions
+    }
+
+    public void worldtick2(boolean runsNormally, BooleanSupplier hasTimeLeft, ServerRegions.WorldTickData tickData) {
+        this.raids.globalTick();
+    // Canvas end
+        if (!this.server.isRegionized()) this.getChunkSource().tick(hasTimeLeft, true); // Canvas - Threaded Regions
+        if (runsNormally && !this.server.isRegionized()) { // Canvas - Threaded Regions - ensure regionized
+            // Canvas start
+            if (this.ticksSinceLastBlockEventsTickCall++ > Config.INSTANCE.ticksBetweenBlockEvents) {
             this.runBlockEvents();
+            this.ticksSinceLastBlockEventsTickCall = 0;
+            }
+            // Canvas end
         }
 
-        this.handlingTick = false;
-        profilerFiller.pop();
-        boolean flag = !paperConfig().unsupportedSettings.disableWorldTickingWhenEmpty || !this.players.isEmpty() || !this.getForceLoadedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players // Paper - restore this
+        tickData.setHandlingTick(false); // Canvas - Threaded Regions
+        boolean flag = true || !this.players.isEmpty() || !this.getForceLoadedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players // Paper - restore this // Canvas - unrestore this
         if (flag) {
             this.resetEmptyTime();
         }
 
+    // Canvas start - Threaded Regions
+        if (!this.server.isRegionized()) this.regiontick3(flag, runsNormally, tickData);
+        worldtick3(tickData);
+    }
+
+    public void regiontick3(boolean flag, boolean runsNormally, ServerRegions.WorldTickData tickData) {
+        TickRateManager tickRateManager = this.tickRateManager();
+    // Canvas end
         if (flag || this.emptyTime++ < 300) {
-            profilerFiller.push("entities");
             if (this.dragonFight != null && runsNormally) {
-                profilerFiller.push("dragonFight");
+                // Canvas start - Threaded Regions
+                if (io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(this, this.dragonFight.origin)) {
                 this.dragonFight.tick();
-                profilerFiller.pop();
+                } else {
+                    // try to load dragon fight
+                    ChunkPos fightCenter = new ChunkPos(this.dragonFight.origin);
+                    this.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                        TicketType.UNKNOWN, fightCenter, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+                        null
+                    );
+                }
+                // Canvas end
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
-            this.entityTickList
-                .forEach(
+            // Canvas start - cache eligible players for despawn checks
+            List<ServerPlayer> localPlayers = tickData.getLocalPlayers();
+            List<ServerPlayer> serverPlayers = new ArrayList<>(localPlayers.size());
+            for (int i = 0; i < localPlayers.size(); i++) {
+                ServerPlayer player = localPlayers.get(i);
+                if (net.minecraft.world.entity.EntitySelector.PLAYER_AFFECTS_SPAWNING.test(player)) {
+                    serverPlayers.add(player);
+                }
+            }
+
+            tickData.eligibleDespawnCheckingPlayerCache = serverPlayers.toArray(new Player[0]);
+            // Canvas end
+            tickData.forEachTickingEntity( // Canvas - Threaded Regions
                     entity -> {
+                        entity.activatedPriorityReset = false; // Canvas - DAB
                         if (!entity.isRemoved()) {
                             if (!tickRateManager.isEntityFrozen(entity)) {
-                                profilerFiller.push("checkDespawn");
+                                if (entity instanceof Mob mob && !(mob instanceof WitherBoss) && !(mob instanceof EnderDragon)) mob.temporaryRegionizedData = tickData; // Canvas - check eligible players for despawn checks
                                 entity.checkDespawn();
-                                profilerFiller.pop();
                                 if (true) { // Paper - rewrite chunk system
                                     Entity vehicle = entity.getVehicle();
                                     if (vehicle != null) {
@@ -824,39 +_,56 @@
                                         entity.stopRiding();
                                     }
 
-                                    profilerFiller.push("tick");
                                     this.guardEntityTick(this::tickNonPassenger, entity);
-                                    profilerFiller.pop();
                                 }
                             }
                         }
                     }
                 );
-            profilerFiller.pop();
             this.tickBlockEntities();
         }
 
-        profilerFiller.push("entityManagement");
+    // Canvas start - Threaded Regions
+        tickPlayerList(tickData); // Canvas - Threaded Regions
+        if (false) for (ServerPlayer player : tickData.getLocalPlayers()) { // Canvas - Threaded Regions
+            player.connection.chunkSender.sendNextChunks(player);
+            player.connection.resumeFlushing();
+        }
+        tickData.explosionDensityCache.clear(); // Canvas - Threaded Regions - we can run this on just the region tick, since we always access this using regionized tick data
+    }
+    public void worldtick3(ServerRegions.WorldTickData tickData) {
+    // Canvas end
         // Paper - rewrite chunk system
-        profilerFiller.pop();
+        // Canvas start - Threaded Dimensions
+        // tickPlayerList(); // Canvas - Threaded Regions
+        this.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
+        // Canvas end
     }
 
     @Override
     public boolean shouldTickBlocksAt(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        return holder != null && holder.isTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.blockTickingChunkHolders.contains(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     protected void tickTime() {
         if (this.tickTime) {
+            ServerRegions.WorldTickData tickData = ServerRegions.getTickData(this); // Canvas - Threaded Regions
+            tickData.incrementRedstoneTime(); // Canvas - Threaded Regions
             long l = this.levelData.getGameTime() + 1L;
             this.serverLevelData.setGameTime(l);
-            Profiler.get().push("scheduledFunctions");
-            this.serverLevelData.getScheduledEvents().tick(this.server, l);
-            Profiler.get().pop();
-            if (this.serverLevelData.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
+            if (!this.server.isRegionized()) this.serverLevelData.getScheduledEvents().tick(this.server, l); // Canvas - Threaded Regions
+            // Canvas start - Threaded Regions
+            boolean canTickDaylight = false;
+            if (this.server.isRegionized() && tickData.region == null/*regions enabled, and we are ticking on a world*/) {
+                canTickDaylight = true;
+            } else if (!this.server.isRegionized()) {
+                // regions disabled, we are without a doubt ticking on world
+                canTickDaylight = true;
+            }
+            if (canTickDaylight && this.serverLevelData.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
+            // Canvas end
                 // Purpur start - Configurable daylight cycle
                 int incrementTicks = isBrightOutside() ? this.purpurConfig.daytimeTicks : this.purpurConfig.nighttimeTicks;
                 if (incrementTicks != 12000) {
@@ -864,10 +_,18 @@
                     this.setDayTime(this.preciseTime);
                 } else
                 // Purpur end - Configurable daylight cycle
-                this.setDayTime(this.levelData.getDayTime() + 1L);
+                this.setDayTime(lagCompensation(this.levelData.getDayTime(), tickData) + 1L); // Canvas - lag compensation - Threaded Regions
+                if (!this.server.isRegionized()) this.syncTimeToPlayers(); // Canvas - Threaded Regions
             }
         }
     }
+    // Canvas start - lag compensation
+
+    private long lagCompensation(long original, ServerRegions.WorldTickData tickData) { // Canvas - Threaded Regions
+        if (!Config.INSTANCE.lagCompensation.enabled || !Config.INSTANCE.lagCompensation.timeAcceleration) return original;
+        return original + tickData.tpsCalculator.applicableMissedTicks(); // Canvas - Threaded Regions
+    }
+    // Canvas end
 
     public void setDayTime(long time) {
         this.serverLevelData.setDayTime(time);
@@ -888,23 +_,29 @@
     // Purpur end - Configurable daylight cycle
 
     public void tickCustomSpawners(boolean spawnEnemies, boolean spawnFriendlies) {
+        // Canvas start
+        if (this.ticksSinceLastTickCustomSpawnersCall++ > Config.INSTANCE.ticksBetweenCustomSpawnersTick) {
         for (CustomSpawner customSpawner : this.customSpawners) {
             customSpawner.tick(this, spawnEnemies, spawnFriendlies);
         }
+        this.ticksSinceLastTickCustomSpawnersCall = 0;
+        }
+        // Canvas end
     }
 
     private void wakeUpAllPlayers() {
         this.sleepStatus.removeAllSleepers();
         this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach(player -> player.stopSleepInBed(false, false));
+        this.server.forceTimeSynchronization(); // Canvas
     }
 
     // Paper start - optimise random ticking
-    private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed());
+    public final SimpleThreadLocalRandomSource simpleRandom = SimpleThreadLocalRandomSource.INSTANCE; // Canvas - threadlocal - private -> public
 
     private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed) {
         final LevelChunkSection[] sections = chunk.getSections();
-        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection((ServerLevel)(Object)this);
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom;
+        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(this); // Canvas - Micro optimizations for random tick - no redundant cast
+        final SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Canvas
         final boolean doubleTickFluids = !ca.spottedleaf.moonrise.common.PlatformHooks.get().configFixMC224294();
 
         final ChunkPos cpos = chunk.getPos();
@@ -912,53 +_,51 @@
         final int offsetZ = cpos.z << 4;
 
         for (int sectionIndex = 0, sectionsLen = sections.length; sectionIndex < sectionsLen; sectionIndex++) {
-            final int offsetY = (sectionIndex + minSection) << 4;
+            // Canvas start - Micro optimizations for random tick
             final LevelChunkSection section = sections[sectionIndex];
-            final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> states = section.states;
             if (!section.isRandomlyTickingBlocks()) {
                 continue;
             }
+            final int offsetY = (sectionIndex + minSection) << 4;
+            final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> states = section.states;
+            // Canvas end - Micro optimizations for random tick
 
-            final ca.spottedleaf.moonrise.common.list.ShortList tickList = ((ca.spottedleaf.moonrise.patches.block_counting.BlockCountingChunkSection)section).moonrise$getTickingBlockList();
+            final ca.spottedleaf.moonrise.common.list.ShortList tickList = section.moonrise$getTickingBlockList(); // Canvas - Micro optimizations for random tick - no redundant cast
 
             for (int i = 0; i < tickSpeed; ++i) {
-                final int tickingBlocks = tickList.size();
                 final int index = simpleRandom.nextInt() & ((16 * 16 * 16) - 1);
 
-                if (index >= tickingBlocks) {
+                if (index >= tickList.size()) { // Canvas - Micro optimizations for random tick - inline one-time value
                     // most of the time we fall here
                     continue;
                 }
 
-                final int location = (int)tickList.getRaw(index) & 0xFFFF;
+                final int location = tickList.getRaw(index); // Canvas - Micro optimizations for random tick - no unnecessary operations
                 final BlockState state = states.get(location);
 
                 // do not use a mutable pos, as some random tick implementations store the input without calling immutable()!
-                final BlockPos pos = new BlockPos((location & 15) | offsetX, ((location >>> (4 + 4)) & 15) | offsetY, ((location >>> 4) & 15) | offsetZ);
+                final BlockPos pos = new BlockPos((location & 15) | offsetX, (location >>> (4 + 4)) | offsetY, ((location >>> 4) & 15) | offsetZ); // Canvas - Micro optimizations for random tick - no redundant mask
 
-                state.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
+                state.randomTick(this, pos, simpleRandom); // Canvas - Micro optimizations for random tick - no redundant cast
                 if (doubleTickFluids) {
                     final FluidState fluidState = state.getFluidState();
                     if (fluidState.isRandomlyTicking()) {
-                        fluidState.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
+                        fluidState.randomTick(this, pos, simpleRandom); // Canvas - Micro optimizations for random tick - no redundant cast
                     }
                 }
             }
         }
-
-        return;
+        // Canvas - Micro optimizations for random tick - no redundant return
     }
     // Paper end - optimise random ticking
 
-    public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom; // Paper - optimise random ticking
+    public void tickChunk(LevelChunk chunk, int randomTickSpeed, ServerRegions.WorldTickData tickData) { // Canvas - Threaded Regions
+        final SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Canvas - Threaded Regions
         ChunkPos pos = chunk.getPos();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("iceandsnow");
 
-        if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
+        if (!this.paperConfig().environment.disableIceAndSnow && chunk.ticksSinceLastPrecipitationCall++ > Config.INSTANCE.ticksBetweenPrecipitationUpdates) { chunk.ticksSinceLastPrecipitationCall = 0; // Paper - Option to disable ice and snow // Canvas - precipitation intervals
         for (int i = 0; i < randomTickSpeed; i++) {
             if (simpleRandom.nextInt(48) == 0) {  // Paper - optimise random ticking
                 this.tickPrecipitation(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
@@ -966,12 +_,12 @@
         }
         } // Paper - Option to disable ice and snow
 
-        profilerFiller.popPush("tickBlocks");
-        if (randomTickSpeed > 0) {
-            this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
+        if (randomTickSpeed > 0 && (chunk.ticksSinceLastRandomTickCall++ > Config.INSTANCE.ticksBetweenRandomTickUpdates && randomTickSpeed > 0)) { chunk.ticksSinceLastRandomTickCall = 0; // Canvas - random tick intervals
+            // Canvas start - optimize random tick
+            if (Config.INSTANCE.ticking.optimizedRandomTick) tickData.randomTickSystem.tickChunk(this.simpleRandom, chunk, randomTickSpeed);
+            else this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
+            // Canvas end
         }
-
-        profilerFiller.pop();
     }
 
     public void tickThunder(LevelChunk chunk) {
@@ -979,8 +_,6 @@
         boolean isRaining = this.isRaining();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("thunder");
         if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
             BlockPos blockPos = this.findLightningTargetAround(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             if (this.isRainingAt(blockPos)) {
@@ -1014,8 +_,6 @@
                 }
             }
         }
-
-        profilerFiller.pop();
     }
 
     @VisibleForTesting
@@ -1119,7 +_,7 @@
     }
 
     public boolean isHandlingTick() {
-        return this.handlingTick;
+        return ServerRegions.getTickData(this).isHandlingTick(); // Canvas - Threaded Regions
     }
 
     public boolean canSleepThroughNights() {
@@ -1308,14 +_,22 @@
     }
 
     private void tickFluid(BlockPos pos, Fluid fluid) {
-        BlockState blockState = this.getBlockState(pos);
+        // Canvas start
+        int x = SectionPos.blockToSectionCoord(pos.getX());
+        int z = SectionPos.blockToSectionCoord(pos.getZ());
+        LevelChunk chunk = this.chunkSource.getChunkAtIfLoadedImmediately(x, z);
+        if (chunk == null) {
+            return;
+        }
+        BlockState blockState = chunk.getBlockState(pos);
+        // Canvas end
         FluidState fluidState = blockState.getFluidState();
         if (fluidState.is(fluid)) {
             fluidState.tick(this, pos, blockState);
         }
         // Paper start - rewrite chunk system
         if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+            this.chunkSource.pollTask(); // Canvas - poll task, as executeMidTickTasks does nothing now
         }
         // Paper end - rewrite chunk system
 
@@ -1328,7 +_,7 @@
         }
         // Paper start - rewrite chunk system
         if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+            this.chunkSource.pollTask(); // Canvas - poll task, as executeMidTickTasks does nothing now
         }
         // Paper end - rewrite chunk system
 
@@ -1336,59 +_,54 @@
 
     // Paper start - log detailed entity tick information
     // TODO replace with varhandle
-    static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
+    // Canvas start
+    /* static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
 
     public static List<Entity> getCurrentlyTickingEntities() {
         Entity ticking = currentlyTickingEntity.get();
         List<Entity> ret = java.util.Arrays.asList(ticking == null ? new Entity[0] : new Entity[] { ticking });
 
         return ret;
-    }
+    } */ // Canvas end
     // Paper end - log detailed entity tick information
 
     public void tickNonPassenger(Entity entity) {
-        // Paper start - log detailed entity tick information
+        /* // Paper start - log detailed entity tick information // Canvas start
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot tick an entity off-main");
         try {
             if (currentlyTickingEntity.get() == null) {
                 currentlyTickingEntity.lazySet(entity);
             }
-            // Paper end - log detailed entity tick information
+            // Paper end - log detailed entity tick information */ // Canvas end
         entity.setOldPosAndRot();
-        ProfilerFiller profilerFiller = Profiler.get();
         entity.tickCount++;
         entity.totalEntityAge++; // Paper - age-like counter for all entities
-        profilerFiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString());
-        profilerFiller.incrementCounter("tickNonPassenger");
         final boolean isActive = io.papermc.paper.entity.activation.ActivationRange.checkIfActive(entity); // Paper - EAR 2
         if (isActive) { // Paper - EAR 2
         entity.tick();
         entity.postTick(); // CraftBukkit
         } else {entity.inactiveTick();} // Paper - EAR 2
-        profilerFiller.pop();
 
         for (Entity entity1 : entity.getPassengers()) {
+            if (entity1 == null) continue; // Canvas - Threaded Regions
             this.tickPassenger(entity, entity1, isActive); // Paper - EAR 2
         }
         // Paper start - log detailed entity tick information
-        } finally {
+        /* } finally { // Canvas start
             if (currentlyTickingEntity.get() == entity) {
                 currentlyTickingEntity.lazySet(null);
             }
-        }
+        } */ // Canvas end
         // Paper end - log detailed entity tick information
     }
 
     private void tickPassenger(Entity ridingEntity, Entity passengerEntity, final boolean isActive) { // Paper - EAR 2
         if (passengerEntity.isRemoved() || passengerEntity.getVehicle() != ridingEntity) {
             passengerEntity.stopRiding();
-        } else if (passengerEntity instanceof Player || this.entityTickList.contains(passengerEntity)) {
+        } else if (passengerEntity instanceof Player || ServerRegions.getTickData(this).hasEntityTickingEntity(passengerEntity)) { // Canvas - Threaded Regions
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
-            ProfilerFiller profilerFiller = Profiler.get();
-            profilerFiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(passengerEntity.getType()).toString());
-            profilerFiller.incrementCounter("tickPassenger");
             // Paper start - EAR 2
             if (isActive) {
             passengerEntity.rideTick();
@@ -1400,7 +_,6 @@
                 ridingEntity.positionRider(passengerEntity);
             }
             // Paper end - EAR 2
-            profilerFiller.pop();
 
             for (Entity entity : passengerEntity.getPassengers()) {
                 this.tickPassenger(passengerEntity, entity, isActive); // Paper - EAR 2
@@ -1534,6 +_,19 @@
         return list;
     }
 
+    // Canvas start - Threaded Regions
+    @Nullable
+    public ServerPlayer getRandomLocalPlayer() {
+        List<ServerPlayer> list = this.getLocalPlayers();
+        list = new java.util.ArrayList<>(list);
+        list.removeIf((ServerPlayer player) -> {
+            return !player.isAlive();
+        });
+
+        return list.isEmpty() ? null : (ServerPlayer) list.get(this.random.nextInt(list.size()));
+    }
+
+    // Canvas end
     @Nullable
     public ServerPlayer getRandomPlayer() {
         List<ServerPlayer> players = this.getPlayers(LivingEntity::isAlive);
@@ -1615,8 +_,8 @@
         } else {
             if (entity instanceof net.minecraft.world.entity.item.ItemEntity itemEntity && itemEntity.getItem().isEmpty()) return false; // Paper - Prevent empty items from being added
             // Paper start - capture all item additions to the world
-            if (captureDrops != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) {
-                captureDrops.add((net.minecraft.world.entity.item.ItemEntity) entity);
+            if (captureDrops.get() != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) { // Canvas - threadlocal
+                captureDrops.get().add((net.minecraft.world.entity.item.ItemEntity) entity); // Canvas - threadlocal
                 return true;
             }
             // Paper end - capture all item additions to the world
@@ -1635,7 +_,7 @@
         return this.tryAddFreshEntityWithPassengers(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
     }
 
-    public boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+    public synchronized boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) { // Canvas - synchronize
         // CraftBukkit end
         if (entity.getSelfAndPassengers().map(Entity::getUUID).anyMatch(this.moonrise$getEntityLookup()::hasEntity)) { // Paper - rewrite chunk system
             return false;
@@ -1804,16 +_,43 @@
         // Paper end - Prevent GameEvents being fired from unloaded chunks
         this.gameEventDispatcher.post(gameEvent, pos, context);
     }
+    // Canvas start
+    private final Set<PathNavigation> activeNavigations = new ConcurrentSet<>();
+
+    private Iterator<Mob> getActiveListeners(Set<Mob> set) {
+        return Collections.emptyIterator();
+    }
+
+    public void lithium$setNavigationActive(Mob mobEntity) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        activeNavigations.add((mobEntity).lithium$getRegisteredNavigation());
+    }
+
+    public void lithium$setNavigationInactive(Mob mobEntity) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        activeNavigations.remove((mobEntity).lithium$getRegisteredNavigation());
+    }
+
+    private void updateActiveListeners(BlockPos pos, List<PathNavigation> list) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        for (PathNavigation entityNavigation : activeNavigations) {
+            if (entityNavigation.shouldRecomputePath(pos)) {
+                list.add(entityNavigation);
+            }
+        }
+    }
+    // Canvas end
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get() && false) { // Canvas - threadlocal
             String string = "recursive call to sendBlockUpdated";
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
 
         this.getChunkSource().blockChanged(pos);
-        this.pathTypesByPosCache.invalidate(pos);
+        ServerRegions.WorldTickData data = ServerRegions.getTickData(this); // Canvas - Threaded Regions
+        data.pathTypesByPosCache.invalidate(pos); // Canvas - Threaded Regions
         if (this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
         VoxelShape collisionShape = oldState.getCollisionShape(this, pos);
         VoxelShape collisionShape1 = newState.getCollisionShape(this, pos);
@@ -1821,7 +_,13 @@
             List<PathNavigation> list = new ObjectArrayList<>();
 
             try { // Paper - catch CME see below why
-            for (Mob mob : this.navigatingMobs) {
+                // Canvas start
+                Iterator<Mob> iterator = getActiveListeners(data.navigatingMobs); // Canvas - Threaded Regions
+                updateActiveListeners(pos, list);
+
+                while (iterator.hasNext()) {
+                    Mob mob = iterator.next();
+                // Canvas end
                 PathNavigation navigation = mob.getNavigation();
                 if (navigation.shouldRecomputePath(pos)) {
                     list.add(navigation);
@@ -1838,13 +_,13 @@
             // Paper end - catch CME see below why
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // Canvas - threadlocal
 
                 for (PathNavigation pathNavigation : list) {
                     pathNavigation.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // Canvas - threadlocal
             }
         }
         } // Paper - option to disable pathfinding updates
@@ -1853,33 +_,33 @@
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block) {
         // CraftBukkit start
-        if (this.populating) {
+        if (this.populating.get()) { // Canvas - threadlocal
             return;
         }
         // CraftBukkit end
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement // Canvas - threadlocal
         this.updateNeighborsAt(pos, block, ExperimentalRedstoneUtils.initialOrientation(this, null, null));
     }
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
-        this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, null, orientation);
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement // Canvas - threadlocal
+        this.neighborUpdater.get().updateNeighborsAtExceptFromFacing(pos, block, null, orientation); // Canvas - threadlocal
     }
 
     @Override
     public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block block, Direction facing, @Nullable Orientation orientation) {
-        this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, facing, orientation);
+        this.neighborUpdater.get().updateNeighborsAtExceptFromFacing(pos, block, facing, orientation); // Canvas - threadlocal
     }
 
     @Override
     public void neighborChanged(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        this.neighborUpdater.neighborChanged(pos, block, orientation);
+        this.neighborUpdater.get().neighborChanged(pos, block, orientation); // Canvas - threadlocal
     }
 
     @Override
     public void neighborChanged(BlockState state, BlockPos pos, Block block, @Nullable Orientation orientation, boolean movedByPiston) {
-        this.neighborUpdater.neighborChanged(state, pos, block, orientation, movedByPiston);
+        this.neighborUpdater.get().neighborChanged(state, pos, block, orientation, movedByPiston); // Canvas - threadlocal
     }
 
     @Override
@@ -1969,7 +_,7 @@
         // CraftBukkit end
         ParticleOptions particleOptions = serverExplosion.isSmall() ? smallExplosionParticles : largeExplosionParticles;
 
-        for (ServerPlayer serverPlayer : this.players) {
+        for (ServerPlayer serverPlayer : this.getLocalPlayers(new ChunkPos(new BlockPos((int) Math.round(x), (int) Math.round(y), (int) Math.round(z))))) { // Canvas - Threaded Regions
             if (serverPlayer.distanceToSqr(vec3) < 4096.0) {
                 Optional<Vec3> optional = Optional.ofNullable(serverExplosion.getHitPlayers().get(serverPlayer));
                 serverPlayer.connection.send(new ClientboundExplodePacket(vec3, optional, particleOptions, explosionSound));
@@ -1985,14 +_,17 @@
 
     @Override
     public void blockEvent(BlockPos pos, Block block, int eventID, int eventParam) {
-        this.blockEvents.add(new BlockEventData(pos, block, eventID, eventParam));
+        ServerRegions.getTickData(this).pushBlockEvent(new BlockEventData(pos, block, eventID, eventParam)); // Canvas - Threaded Regions
     }
 
-    private void runBlockEvents() {
-        this.blockEventsToReschedule.clear();
+    public void runBlockEvents() { // Canvas - private -> public
+        List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64); // Canvas - Threaded Regions
 
-        while (!this.blockEvents.isEmpty()) {
-            BlockEventData blockEventData = this.blockEvents.removeFirst();
+        // Canvas start - Threaded Regions
+        ServerRegions.WorldTickData worldTickData = ServerRegions.getTickData(this);
+        BlockEventData blockEventData;
+        while ((blockEventData = worldTickData.removeFirstBlockEvent()) != null) {
+        // Canvas end
             if (this.shouldTickBlocksAt(blockEventData.pos())) {
                 if (this.doBlockEvent(blockEventData)) {
                     this.server
@@ -2008,11 +_,11 @@
                         );
                 }
             } else {
-                this.blockEventsToReschedule.add(blockEventData);
+                blockEventsToReschedule.add(blockEventData); // Canvas - Threaded Regions
             }
         }
 
-        this.blockEvents.addAll(this.blockEventsToReschedule);
+        worldTickData.pushBlockEvents(blockEventsToReschedule); // Canvas - Threaded Regions
     }
 
     private boolean doBlockEvent(BlockEventData event) {
@@ -2022,12 +_,12 @@
 
     @Override
     public LevelTicks<Block> getBlockTicks() {
-        return this.blockTicks;
+        return ServerRegions.getTickData(this).getBlockLevelTicks(); // Canvas - Threaded Regions
     }
 
     @Override
     public LevelTicks<Fluid> getFluidTicks() {
-        return this.fluidTicks;
+        return ServerRegions.getTickData(this).getFluidLevelTicks(); // Canvas - Threaded Regions
     }
 
     @Nonnull
@@ -2080,7 +_,7 @@
         double zOffset,
         double speed
     ) {
-        return sendParticlesSource(this.players, sender, type, overrideLimiter, alwaysShow, posX, posY, posZ, particleCount, xOffset, yOffset, zOffset, speed);
+        return sendParticlesSource(this.getLocalPlayers(new ChunkPos(new BlockPos((int) Math.round(posX), (int) Math.round(posY), (int) Math.round(posZ)))), sender, type, overrideLimiter, alwaysShow, posX, posY, posZ, particleCount, xOffset, yOffset, zOffset, speed); // Canvas - Threaded Regions
     }
     public <T extends ParticleOptions> int sendParticlesSource(
         List<ServerPlayer> receivers,
@@ -2198,10 +_,10 @@
         return this.server.getRecipeManager();
     }
 
-    @Override
+    /* @Override // Canvas start - clashes with super
     public TickRateManager tickRateManager() {
         return this.server.tickRateManager();
-    }
+    } */ // Canvas end
 
     @Override
     public boolean noSave() {
@@ -2218,6 +_,7 @@
         // Paper start - Call missing map initialize event and set id
         final DimensionDataStorage storage = this.getServer().overworld().getDataStorage();
 
+        synchronized (storage.cache) { // Canvas - Threaded Regions
         final Optional<net.minecraft.world.level.saveddata.SavedData> cacheEntry = storage.cache.get(MapItemSavedData.type(mapId));
         if (cacheEntry == null) { // Cache did not contain, try to load and may init
             final MapItemSavedData mapData = storage.get(MapItemSavedData.type(mapId)); // get populates the cache
@@ -2236,6 +_,7 @@
         }
 
         return null;
+        } // Canvas - Threaded Regions
         // Paper end - Call missing map initialize event and set id
     }
 
@@ -2289,7 +_,7 @@
     public boolean setChunkForced(int chunkX, int chunkZ, boolean add) {
         boolean flag = this.chunkSource.updateChunkForced(new ChunkPos(chunkX, chunkZ), add);
         if (add && flag) {
-            this.getChunk(chunkX, chunkZ);
+            // this.getChunk(chunkX, chunkZ); // Canvas - let the chunk load asynchronously
         }
 
         return flag;
@@ -2306,11 +_,11 @@
         Optional<Holder<PoiType>> optional1 = PoiTypes.forState(newState);
         if (!Objects.equals(optional, optional1)) {
             BlockPos blockPos = pos.immutable();
-            optional.ifPresent(holder -> this.getServer().execute(() -> {
+            optional.ifPresent(holder -> this.server.threadedServer().taskQueue.queueChunkTask(this, blockPos.getX() >> 4, blockPos.getZ() >> 4, () -> { // Canvas - Threaded Regions
                 this.getPoiManager().remove(blockPos);
                 DebugPackets.sendPoiRemovedPacket(this, blockPos);
             }));
-            optional1.ifPresent(holder -> this.getServer().execute(() -> {
+            optional1.ifPresent(holder -> this.server.threadedServer().taskQueue.queueChunkTask(this, blockPos.getX() >> 4, blockPos.getZ() >> 4, () -> { // Canvas - Threaded Regions
                 // Paper start - Remove stale POIs
                 if (optional.isEmpty() && this.getPoiManager().exists(blockPos, ignored -> true)) {
                     this.getPoiManager().remove(blockPos);
@@ -2348,7 +_,7 @@
 
     @Nullable
     public Raid getRaidAt(BlockPos pos) {
-        return this.raids.getNearbyRaid(pos, 9216);
+        return this.raids.getNearbyRaid(this, pos, 9216); // Canvas - threadsafe raids
     }
 
     public boolean isRaided(BlockPos pos) {
@@ -2443,14 +_,14 @@
         CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("type").build(output);
 
         for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) {
-            BlockPos pos = tickingBlockEntity.getPos();
+            BlockPos pos = getPosOrOrigin(tickingBlockEntity); // Canvas
             csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
         }
     }
 
     @VisibleForTesting
     public void clearBlockEvents(BoundingBox boundingBox) {
-        this.blockEvents.removeIf(blockEventData -> boundingBox.isInside(blockEventData.pos()));
+        ServerRegions.getTickData(this).removeIfBlockEvents(blockEventData -> boundingBox.isInside(blockEventData.pos())); // Canvas - Threaded Regions
     }
 
     @Override
@@ -2461,10 +_,46 @@
     public Iterable<Entity> getAllEntities() {
         return this.getEntities().getAll();
     }
+    // Canvas start - getAllBlockEntities - getAllRegionizedEntities
+
+    public Iterable<Entity> getAllRegionizedEntities() {
+        Set<Entity> entities = new ObjectHashSet<>();
+        if (this.server.isRegionized()) {
+            this.regioniser.computeForAllRegionsUnsynchronised((region) -> {
+                for (final Entity loadedEntity : region.getData().tickData.getLoadedEntities()) {
+                    entities.add(loadedEntity);
+                }
+            });
+        } else {
+            for (final Entity loadedEntity : ServerRegions.getTickData(this).getLoadedEntities()) {
+                entities.add(loadedEntity);
+            }
+        }
+        return entities;
+    }
+
+    public Iterable<BlockEntity> getAllBlockEntities() {
+        Set<BlockEntity> blockEntities = new ObjectHashSet<>();
+        if (this.server.isRegionized()) {
+            this.regioniser.computeForAllRegionsUnsynchronised((region) -> {
+                for (final LevelChunk chunk : region.getData().tickData.getTickingChunks().getRawDataUnchecked()) {
+                    if (chunk == null) continue;
+                    blockEntities.addAll(chunk.blockEntities.values());
+                }
+            });
+        } else {
+            for (final LevelChunk chunk : ServerRegions.getTickData(this).getTickingChunks().getRawDataUnchecked()) {
+                if (chunk == null) continue;
+                blockEntities.addAll(chunk.blockEntities.values());
+            }
+        }
+        return blockEntities;
+    }
+    // Canvas end
 
     @Override
     public String toString() {
-        return "ServerLevel[" + this.serverLevelData.getLevelName() + "]";
+        return super.toString(); // Canvas - Threaded Dimensions
     }
 
     public boolean isFlat() {
@@ -2485,6 +_,16 @@
     public ServerLevel getLevel() {
         return this;
     }
+    // Canvas start
+
+    private BlockPos getPosOrOrigin(TickingBlockEntity instance) {
+        BlockPos pos = instance.getPos();
+        if (pos == null) {
+            return BlockPos.ZERO;
+        }
+        return pos;
+    }
+    // Canvas end
 
     @VisibleForTesting
     public String getWatchdogStats() {
@@ -2547,19 +_,19 @@
     }
 
     public void startTickingChunk(LevelChunk chunk) {
-        chunk.unpackTicks(this.getLevelData().getGameTime());
+        chunk.unpackTicks(this.getRedstoneGameTime()); // Canvas - Threaded Regions
     }
 
     public void onStructureStartsAvailable(ChunkAccess chunk) {
-        this.server.execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
+        this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts());
     }
 
     public PathTypeCache getPathTypeCache() {
-        return this.pathTypesByPosCache;
+        return ServerRegions.getTickData(this).pathTypesByPosCache; // Canvas - Threaded Regions
     }
 
     @Override
-    public void close() throws IOException {
+    public void close() { // Canvas
         super.close();
         // Paper - rewrite chunk system
     }
@@ -2575,23 +_,19 @@
 
     public boolean isPositionTickingWithEntitiesLoaded(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        // isTicking implies the chunk is loaded, and the chunk is loaded now implies the entities are loaded
-        return chunkHolder != null && chunkHolder.isTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.blockTickingChunkHolders.contains(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     public boolean isPositionEntityTicking(BlockPos pos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos)); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     public boolean areEntitiesActuallyLoadedAndTicking(ChunkPos chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkPos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(chunkPos.longKey); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -2605,8 +_,7 @@
 
     public boolean canSpawnEntitiesInChunk(ChunkPos chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkPos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady() && this.getWorldBorder().isWithinBounds(chunkPos);
+        return areEntitiesActuallyLoadedAndTicking(chunkPos) && this.getWorldBorder().isWithinBounds(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -2674,11 +_,40 @@
     // Paper start - optimize redstone (Alternate Current)
     @Override
     public alternate.current.wire.WireHandler getWireHandler() {
-        return wireHandler;
+        return ServerRegions.getTickData(this).wireHandler; // Canvas - Threaded Regions
     }
     // Paper end - optimize redstone (Alternate Current)
 
     final class EntityCallbacks implements LevelCallback<Entity> {
+        // Canvas start
+        private ServerLevel outer;
+
+        EntityCallbacks() {
+            this.outer = ServerLevel.this;
+        }
+
+        private boolean startListeningOnEntityLoad(java.util.function.Function<Mob, Boolean> addConsumer, Object mobEntityObj) { // Canvas - use function
+            Mob mobEntity = (Mob) mobEntityObj;
+            PathNavigation navigation = mobEntity.getNavigation();
+            (mobEntity).lithium$setRegisteredToWorld(navigation);
+            if (navigation.getPath() != null) {
+                (this.outer).lithium$setNavigationActive(mobEntity);
+            }
+            return addConsumer.apply(mobEntity); // Canvas - use function
+        }
+
+        private boolean stopListeningOnEntityUnload(java.util.function.Function<Mob, Boolean> removeConsumer, Object mobEntityObj) { // Canvas - use function
+            Mob mobEntity = (Mob) mobEntityObj;
+            if ((mobEntity).lithium$isRegisteredToWorld()) {
+                PathNavigation registeredNavigation = ((Mob) mobEntity).lithium$getRegisteredNavigation();
+                if (registeredNavigation.getPath() != null) {
+                    (this.outer).lithium$setNavigationInactive(mobEntity);
+                }
+                (mobEntity).lithium$setRegisteredToWorld(null);
+            }
+            return removeConsumer.apply(mobEntity); // Canvas - use function
+        }
+        // Canvas end
         @Override
         public void onCreated(Entity entity) {
             entity.setOldPosAndRot(); // Paper - update old pos / rot for new entities as it will default to Vec3.ZERO
@@ -2692,12 +_,12 @@
         @Override
         public void onTickingStart(Entity entity) {
             if (entity instanceof net.minecraft.world.entity.Marker && !paperConfig().entities.markers.tick) return; // Paper - Configurable marker ticking
-            ServerLevel.this.entityTickList.add(entity);
+            ServerRegions.getRegionizedTickData(entity.chunkPosition().x, entity.chunkPosition().z, ServerLevel.this).addEntityTickingEntity(entity); // Canvas - Threaded Regions
         }
 
         @Override
         public void onTickingEnd(Entity entity) {
-            ServerLevel.this.entityTickList.remove(entity);
+            ServerRegions.getRegionizedTickData(entity.chunkPosition().x, entity.chunkPosition().z, ServerLevel.this).removeEntityTickingEntity(entity); // Canvas - Threaded Regions
             // Paper start - Reset pearls when they stop being ticked
             if (ServerLevel.this.paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && ServerLevel.this.paperConfig().misc.legacyEnderPearlBehavior && entity instanceof net.minecraft.world.entity.projectile.ThrownEnderpearl pearl) {
                 pearl.cachedOwner = null;
@@ -2708,7 +_,10 @@
 
         @Override
         public void onTrackingStart(Entity entity) {
+            try { entity.statusLock.acquire(); // Canvas - lock tracking
+            TNTMergeManager.onEntityLoad(entity); // Canvas - tnt merging
             org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
+            ServerRegions.getRegionizedTickData(entity.chunkPosition().x, entity.chunkPosition().z, this.outer).addLoadedEntity(entity); // Canvas - Threaded Regions
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.add(serverPlayer);
@@ -2716,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // Canvas - threadlocal
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.add(mob);
+                startListeningOnEntityLoad(ServerRegions.getRegionizedTickData(mob.chunkPosition().x, mob.chunkPosition().z, this.outer)::addNavigatingMob, mob); // Canvas - Threaded Regions - use function
             }
 
             if (entity instanceof EnderDragon enderDragon) {
@@ -2746,23 +_,35 @@
             }
             // Paper end - Entity origin API
             new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entity.getBukkitEntity(), ServerLevel.this.getWorld()).callEvent(); // Paper - fire while valid
+            } finally { entity.statusLock.release(); } // Canvas - lock tracking
         }
 
         @Override
         public void onTrackingEnd(Entity entity) {
+            try { entity.statusLock.acquire(); // Canvas - lock tracking
+            TNTMergeManager.onEntityUnload(entity); // Canvas - tnt merging
             org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
             // Spigot start // TODO I don't think this is needed anymore
+            ServerRegions.getRegionizedTickData(entity.chunkPosition().x, entity.chunkPosition().z, this.outer).removeLoadedEntity(entity); // Canvas - Threaded Regions
             if (entity instanceof Player player) {
                 for (final ServerLevel level : ServerLevel.this.getServer().getAllLevels()) {
-                    for (final Optional<net.minecraft.world.level.saveddata.SavedData> savedData : level.getDataStorage().cache.values()) {
+                    // Canvas start - make map data thread-safe
+                    List<Optional<net.minecraft.world.level.saveddata.SavedData>> worldDataCache;
+                    synchronized (level.getDataStorage().cache) {
+                        worldDataCache = new java.util.ArrayList<>(level.getDataStorage().cache.values());
+                    }
+                    for (final Optional<net.minecraft.world.level.saveddata.SavedData> savedData : worldDataCache) {
+                    // Canvas end
                         if (savedData.isEmpty() || !(savedData.get() instanceof MapItemSavedData map)) {
                             continue;
                         }
 
+                        synchronized (map) { // Canvas - make map data thread-safe
                         map.carriedByPlayers.remove(player);
-                        if (map.carriedBy.removeIf(holdingPlayer -> holdingPlayer.player == player)) {
+                        if (map.carriedBy.removeIf(holdingPlayer -> holdingPlayer != null && holdingPlayer.player == player)) { // Canvas - threaded tracker
                             map.decorations.remove(player.getName().getString());
                         }
+                        } // Canvas - make map data thread-safe
                     }
                 }
             }
@@ -2786,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // Canvas - threadlocal
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.remove(mob);
+                stopListeningOnEntityUnload(ServerRegions.getRegionizedTickData(mob.chunkPosition().x, mob.chunkPosition().z, this.outer)::removeNavigatingMob, mob); // Canvas - Threaded Regions - use function
             }
 
             if (entity instanceof EnderDragon enderDragon) {
@@ -2812,6 +_,7 @@
             }
             // CraftBukkit end
             new com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent(entity.getBukkitEntity(), ServerLevel.this.getWorld()).callEvent(); // Paper - fire while valid
+            } finally { entity.statusLock.release(); } // Canvas - lock tracking
         }
 
         @Override
@@ -2829,14 +_,14 @@
     // Paper end - check global player list where appropriate
 
     // Paper start - lag compensation
-    private long lagCompensationTick = MinecraftServer.SERVER_INIT;
+    // private long lagCompensationTick = MinecraftServer.SERVER_INIT; // Canvas - Threaded Regions
 
     public long getLagCompensationTick() {
-        return this.lagCompensationTick;
+        return ServerRegions.getTickData(this).getLagCompensationTick(); // Canvas - Threaded Regions
     }
 
     public void updateLagCompensationTick() {
-        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / (java.util.concurrent.TimeUnit.MILLISECONDS.toNanos(50L));
+        ServerRegions.getTickData(this).updateLagCompensationTick(); // Canvas - Threaded Regions
     }
     // Paper end - lag compensation
 }
