--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -97,7 +_,7 @@
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.slf4j.Logger;
 
-public final class ItemStack implements DataComponentHolder {
+public final class ItemStack implements DataComponentHolder, io.canvasmc.canvas.util.change_tracking.ChangePublisher<ItemStack>, io.canvasmc.canvas.util.change_tracking.ChangeSubscriber<PatchedDataComponentMap> { // Canvas - equipment tracking
     private static final List<Component> OP_NBT_WARNING = List.of(
         Component.translatable("item.op_warning.line1").withStyle(ChatFormatting.RED, ChatFormatting.BOLD),
         Component.translatable("item.op_warning.line2").withStyle(ChatFormatting.RED),
@@ -168,6 +_,11 @@
     PatchedDataComponentMap components;
     @Nullable
     private Entity entityRepresentation;
+    // Canvas start - equipment tracking
+    @Nullable
+    private io.canvasmc.canvas.util.change_tracking.ChangeSubscriber<ItemStack> subscriber;
+    private int subscriberData;
+    // Canvas end - equipment tracking
 
     public static DataResult<ItemStack> validateStrict(ItemStack stack) {
         DataResult<Unit> dataResult = validateComponents(stack.getComponents());
@@ -387,29 +_,29 @@
             ServerLevel serverLevel = (ServerLevel) context.getLevel();
 
             if (!(item instanceof BucketItem/* || item instanceof SolidBucketItem*/)) { // if not bucket // Paper - Fix cancelled powdered snow bucket placement
-                serverLevel.captureBlockStates = true;
+                serverLevel.captureBlockStates.set(true); // Canvas - threadlocal
                 // special case bonemeal
                 if (item == Items.BONE_MEAL) {
-                    serverLevel.captureTreeGeneration = true;
+                    serverLevel.captureTreeGeneration.set(true); // Canvas - threadlocal
                 }
             }
             InteractionResult interactionResult;
             try {
                 interactionResult = item.useOn(context);
             } finally {
-                serverLevel.captureBlockStates = false;
+                serverLevel.captureBlockStates.set(false); // Canvas - threadlocal
             }
             DataComponentPatch newPatch = this.components.asPatch();
             int newCount = this.getCount();
             this.setCount(oldCount);
             this.restorePatch(previousPatch);
-            if (interactionResult.consumesAction() && serverLevel.captureTreeGeneration && !serverLevel.capturedBlockStates.isEmpty()) {
-                serverLevel.captureTreeGeneration = false;
+            if (interactionResult.consumesAction() && serverLevel.captureTreeGeneration.get() && !serverLevel.capturedBlockStates.get().isEmpty()) { // Canvas - threadlocal
+                serverLevel.captureTreeGeneration.set(false); // Canvas - threadlocal
                 org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(clickedPos, serverLevel.getWorld());
                 org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
                 net.minecraft.world.level.block.SaplingBlock.treeType = null;
-                List<org.bukkit.craftbukkit.block.CraftBlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.values());
-                serverLevel.capturedBlockStates.clear();
+                List<org.bukkit.craftbukkit.block.CraftBlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.get().values()); // Canvas - threadlocal
+                serverLevel.capturedBlockStates.get().clear(); // Canvas - threadlocal
                 org.bukkit.event.world.StructureGrowEvent structureEvent = null;
                 if (treeType != null) {
                     boolean isBonemeal = this.getItem() == Items.BONE_MEAL;
@@ -435,15 +_,15 @@
                     player.awardStat(Stats.ITEM_USED.get(item)); // SPIGOT-7236 - award stat
                 }
 
-                SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
+                SignItem.openSign.remove(); // SPIGOT-6758 - Reset on early return // Canvas - threadlocal
                 return interactionResult;
             }
-            serverLevel.captureTreeGeneration = false;
+            serverLevel.captureTreeGeneration.set(false); // Canvas - threadlocal
             if (player != null && interactionResult instanceof InteractionResult.Success success && success.wasItemInteraction()) {
                 InteractionHand hand = context.getHand();
                 org.bukkit.event.block.BlockPlaceEvent placeEvent = null;
-                List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.values());
-                serverLevel.capturedBlockStates.clear();
+                List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.get().values()); // Canvas - threadlocal
+                serverLevel.capturedBlockStates.get().clear(); // Canvas - threadlocal
                 if (blocks.size() > 1) {
                     placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockMultiPlaceEvent(serverLevel, player, hand, blocks, clickedPos);
                 } else if (blocks.size() == 1 && item != Items.POWDER_SNOW_BUCKET) { // Paper - Fix cancelled powdered snow bucket placement
@@ -454,14 +_,14 @@
                     interactionResult = InteractionResult.FAIL; // cancel placement
                     // PAIL: Remove this when MC-99075 fixed
                     player.containerMenu.sendAllDataToRemote();
-                    serverLevel.capturedTileEntities.clear(); // Paper - Allow chests to be placed with NBT data; clear out block entities as chests and such will pop loot
+                    serverLevel.capturedTileEntities.get().clear(); // Paper - Allow chests to be placed with NBT data; clear out block entities as chests and such will pop loot // Canvas - threadlocal
                     // revert back all captured blocks
                     for (org.bukkit.block.BlockState blockstate : blocks) {
                         ((org.bukkit.craftbukkit.block.CraftBlockState) blockstate).revertPlace();
                         ((org.bukkit.craftbukkit.block.CraftBlock) blockstate.getBlock()).getNMS().getBlock().forgetPlacer(); // Purpur - Store placer on Block when placed
                     }
 
-                    SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
+                    SignItem.openSign.remove(); // SPIGOT-6758 - Reset on early return // Canvas - threadlocal
                 } else {
                     // Change the stack to its new contents if it hasn't been tampered with.
                     if (this.getCount() == oldCount && Objects.equals(this.components.asPatch(), previousPatch)) {
@@ -469,7 +_,7 @@
                         this.setCount(newCount);
                     }
 
-                    for (java.util.Map.Entry<BlockPos, net.minecraft.world.level.block.entity.BlockEntity> e : serverLevel.capturedTileEntities.entrySet()) {
+                    for (java.util.Map.Entry<BlockPos, net.minecraft.world.level.block.entity.BlockEntity> e : serverLevel.capturedTileEntities.get().entrySet()) { // Canvas - threadlocal
                         serverLevel.setBlockEntity(e.getValue());
                     }
 
@@ -505,15 +_,15 @@
                     }
 
                     // SPIGOT-4678
-                    if (this.item instanceof SignItem && SignItem.openSign != null) {
+                    if (this.item instanceof SignItem && SignItem.openSign.get() != null) { // Canvas - thread local
                         try {
-                            if (serverLevel.getBlockEntity(SignItem.openSign) instanceof net.minecraft.world.level.block.entity.SignBlockEntity blockEntity) {
-                                if (serverLevel.getBlockState(SignItem.openSign).getBlock() instanceof net.minecraft.world.level.block.SignBlock signBlock) {
+                            if (serverLevel.getBlockEntity(SignItem.openSign.get()) instanceof net.minecraft.world.level.block.entity.SignBlockEntity blockEntity) { // Canvas - thread local
+                                if (serverLevel.getBlockState(SignItem.openSign.get()).getBlock() instanceof net.minecraft.world.level.block.SignBlock signBlock) { // Canvas - thread local
                                     signBlock.openTextEdit(player, blockEntity, true, io.papermc.paper.event.player.PlayerOpenSignEvent.Cause.PLACE); // CraftBukkit // Paper - Add PlayerOpenSignEvent
                                 }
                             }
                         } finally {
-                            SignItem.openSign = null;
+                            SignItem.openSign.remove(); // Canvas - thread local
                         }
                     }
 
@@ -540,8 +_,8 @@
                     player.awardStat(Stats.ITEM_USED.get(item));
                 }
             }
-            serverLevel.capturedTileEntities.clear();
-            serverLevel.capturedBlockStates.clear();
+            serverLevel.capturedTileEntities.get().clear();
+            serverLevel.capturedBlockStates.get().clear(); // Canvas - threadlocal
             // CraftBukkit end
 
             return interactionResult;
@@ -918,11 +_,11 @@
     }
 
     public static boolean isSameItem(ItemStack stack, ItemStack other) {
-        return stack.is(other.getItem());
+        return stack == other || stack.is(other.getItem()); // Canvas - optimize identical item checks
     }
 
     public static boolean isSameItemSameComponents(ItemStack stack, ItemStack other) {
-        return stack.is(other.getItem()) && (stack.isEmpty() && other.isEmpty() || Objects.equals(stack.components, other.components));
+        return stack == other || stack.is(other.getItem()) && (stack.isEmpty() && other.isEmpty() || Objects.equals(stack.components, other.components)); // Canvas - optimize identical item checks
     }
 
     public static MapCodec<ItemStack> lenientOptionalFieldOf(String fieldName) {
@@ -1402,6 +_,21 @@
     }
 
     public void setCount(int count) {
+        // Canvas start - equipment tracking
+        if (count != this.count) {
+            if (this.subscriber instanceof io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.CountChangeSubscriber<ItemStack> countChangeSubscriber) {
+                countChangeSubscriber.lithium$notifyCount(this, this.subscriberData, count);
+            }
+            if (count == 0) {
+                this.components.lithium$unsubscribe(this);
+                if (this.subscriber != null) {
+                    this.subscriber.lithium$forceUnsubscribe(this, this.subscriberData);
+                    this.subscriber = null;
+                    this.subscriberData = 0;
+                }
+            }
+        }
+        // Canvas end - equipment tracking
         this.count = count;
     }
 
@@ -1457,4 +_,87 @@
     public boolean canDestroyBlock(BlockState state, Level level, BlockPos pos, Player player) {
         return this.getItem().canDestroyBlock(this, state, level, pos, player);
     }
+
+    // Canvas start - equipment tracking
+    @Override
+    public void lithium$subscribe(io.canvasmc.canvas.util.change_tracking.ChangeSubscriber<ItemStack> subscriber, int subscriberData) {
+        if (this.isEmpty()) {
+            throw new IllegalStateException("Cannot subscribe to an empty ItemStack!");
+        }
+
+        if (this.subscriber == null) {
+            this.startTrackingChanges();
+        }
+        this.subscriber = io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.combine(this.subscriber, this.subscriberData, subscriber, subscriberData);
+        if (this.subscriber instanceof io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.Multi<?>) {
+            this.subscriberData = 0;
+        } else {
+            this.subscriberData = subscriberData;
+        }
+    }
+
+    @Override
+    public int lithium$unsubscribe(io.canvasmc.canvas.util.change_tracking.ChangeSubscriber<ItemStack> subscriber) {
+        if (this.isEmpty()) {
+            throw new IllegalStateException("Cannot unsubscribe from an empty ItemStack!");
+        }
+
+        int retval = io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.dataOf(this.subscriber, subscriber, this.subscriberData);
+        this.subscriberData = io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.dataWithout(this.subscriber, subscriber, this.subscriberData);
+        this.subscriber = io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.without(this.subscriber, subscriber);
+
+        if (this.subscriber == null) {
+            this.components.lithium$unsubscribe(this);
+        }
+        return retval;
+    }
+
+    @Override
+    public void lithium$unsubscribeWithData(io.canvasmc.canvas.util.change_tracking.ChangeSubscriber<ItemStack> subscriber, int subscriberData) {
+        if (this.isEmpty()) {
+            throw new IllegalStateException("Cannot unsubscribe from an empty ItemStack!");
+        }
+
+        this.subscriberData = io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.dataWithout(this.subscriber, subscriber, this.subscriberData, subscriberData, true);
+        this.subscriber = io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.without(this.subscriber, subscriber, subscriberData, true);
+
+        if (this.subscriber == null) {
+            this.components.lithium$unsubscribe(this);
+        }
+    }
+
+    @Override
+    public boolean lithium$isSubscribedWithData(io.canvasmc.canvas.util.change_tracking.ChangeSubscriber<ItemStack> subscriber, int subscriberData) {
+        if (this.isEmpty()) {
+            throw new IllegalStateException("Cannot be subscribed to an empty ItemStack!");
+        }
+
+        return io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.containsSubscriber(this.subscriber, this.subscriberData, subscriber, subscriberData);
+    }
+
+    @Override
+    public void lithium$forceUnsubscribe(PatchedDataComponentMap publisher, int subscriberData) {
+        if (publisher != this.components) {
+            throw new IllegalStateException("Invalid publisher, expected " + this.components + " but got " + publisher);
+        }
+        this.subscriber.lithium$forceUnsubscribe(this, this.subscriberData);
+        this.subscriber = null;
+        this.subscriberData = 0;
+    }
+
+    @Override
+    public void lithium$notify(PatchedDataComponentMap publisher, int subscriberData) {
+        if (publisher != this.components) {
+            throw new IllegalStateException("Invalid publisher, expected " + this.components + " but got " + publisher);
+        }
+
+        if (this.subscriber != null) {
+            this.subscriber.lithium$notify(this, this.subscriberData);
+        }
+    }
+
+    private void startTrackingChanges() {
+        this.components.lithium$subscribe(this, 0);
+    }
+    // Canvas end - equipment tracking
 }
