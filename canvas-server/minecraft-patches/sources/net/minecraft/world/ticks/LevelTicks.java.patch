--- a/net/minecraft/world/ticks/LevelTicks.java
+++ b/net/minecraft/world/ticks/LevelTicks.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.ticks;
 
+import io.canvasmc.canvas.region.ServerRegions;
 import it.unimi.dsi.fastutil.longs.Long2LongMap;
 import it.unimi.dsi.fastutil.longs.Long2LongMaps;
 import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
@@ -16,6 +_,7 @@
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.BiConsumer;
 import java.util.function.LongPredicate;
 import java.util.function.Predicate;
@@ -23,8 +_,6 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.Vec3i;
-import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 
@@ -43,12 +_,78 @@
             this.updateContainerScheduling(scheduledTick);
         }
     };
-
-    public LevelTicks(LongPredicate tickCheck) {
+    public int ticksSinceLastBlockTickCall; // Canvas - ticks between config
+    public int ticksSinceLastFluidTickCall; // Canvas - ticks between config
+
+    // Canvas start - Threaded Regions
+    public final net.minecraft.server.level.ServerLevel world;
+    public final boolean isBlock;
+    public final boolean isWorldRegion;
+    // we lock down for concurrency purposes, if we don't, we can crash anytime which very bad
+    private final ReentrantLock lock = new ReentrantLock();
+
+    public void merge(final LevelTicks<T> into, final long tickOffset) {
+        // note: containersToTick, toRunThisTick, alreadyRunThisTick, toRunThisTickSet
+        // are all transient state, only ever non-empty during tick. But merging regions occurs while there
+        // is no tick happening, so we assume they are empty.
+        for (final java.util.Iterator<Long2ObjectMap.Entry<LevelChunkTicks<T>>> iterator =
+             ((Long2ObjectOpenHashMap<LevelChunkTicks<T>>)this.allContainers).long2ObjectEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2ObjectMap.Entry<LevelChunkTicks<T>> entry = iterator.next();
+            final LevelChunkTicks<T> tickContainer = entry.getValue();
+            tickContainer.offsetTicks(tickOffset);
+            into.allContainers.put(entry.getLongKey(), tickContainer);
+        }
+        for (final java.util.Iterator<Long2LongMap.Entry> iterator = ((Long2LongOpenHashMap)this.nextTickForContainer).long2LongEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2LongMap.Entry entry = iterator.next();
+            into.nextTickForContainer.put(entry.getLongKey(), entry.getLongValue() + tickOffset);
+        }
+    }
+
+    public void split(final int chunkToRegionShift,
+                      final it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap<LevelTicks<T>> regionToData) {
+        for (final java.util.Iterator<Long2ObjectMap.Entry<LevelChunkTicks<T>>> iterator =
+             ((Long2ObjectOpenHashMap<LevelChunkTicks<T>>)this.allContainers).long2ObjectEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2ObjectMap.Entry<LevelChunkTicks<T>> entry = iterator.next();
+
+            final long chunkKey = entry.getLongKey();
+            final int chunkX = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkKey);
+            final int chunkZ = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkKey);
+
+            final long regionSectionKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(
+                chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift
+            );
+            // Should always be non-null, since containers are removed on unload.
+            regionToData.get(regionSectionKey).allContainers.put(chunkKey, entry.getValue());
+        }
+        for (final java.util.Iterator<Long2LongMap.Entry> iterator = ((Long2LongOpenHashMap)this.nextTickForContainer).long2LongEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2LongMap.Entry entry = iterator.next();
+            final long chunkKey = entry.getLongKey();
+            final int chunkX = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkKey);
+            final int chunkZ = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkKey);
+
+            final long regionSectionKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(
+                chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift
+            );
+
+            // Should always be non-null, since containers are removed on unload.
+            regionToData.get(regionSectionKey).nextTickForContainer.put(chunkKey, entry.getLongValue());
+        }
+    }
+
+    public LevelTicks(LongPredicate tickCheck, net.minecraft.server.level.ServerLevel world, boolean isBlock, boolean isWorldRegion) {
+        this.world = world;
+        this.isBlock = isBlock;
+        this.isWorldRegion = isWorldRegion;
+        // Canvas end
         this.tickCheck = tickCheck;
     }
 
     public void addContainer(ChunkPos chunkPos, LevelChunkTicks<T> chunkTicks) {
+        try { lock.lock(); // Canvas - lock
         long packedChunkPos = chunkPos.toLong();
         this.allContainers.put(packedChunkPos, chunkTicks);
         ScheduledTick<T> scheduledTick = chunkTicks.peek();
@@ -56,20 +_,33 @@
             this.nextTickForContainer.put(packedChunkPos, scheduledTick.triggerTick());
         }
 
-        chunkTicks.setOnTickAdded(this.chunkScheduleUpdater);
+        final boolean isBlock = this.isBlock;
+        final net.minecraft.server.level.ServerLevel world = this.world;
+        // make sure the lambda contains no reference to this LevelTicks
+        chunkTicks.setOnTickAdded((LevelChunkTicks<T> levelChunkTicks, ScheduledTick<T> tick) -> {
+            if (tick.equals(levelChunkTicks.peek())) {
+                ServerRegions.WorldTickData worldData = ServerRegions.getTickData(world);
+                ((LevelTicks<T>)(isBlock ? worldData.getBlockLevelTicks() : worldData.getFluidLevelTicks())).updateContainerScheduling(tick);
+            }
+        });
+        // Canvas end
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     public void removeContainer(ChunkPos chunkPos) {
+        try { lock.lock(); // Canvas - lock
         long packedChunkPos = chunkPos.toLong();
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.remove(packedChunkPos);
         this.nextTickForContainer.remove(packedChunkPos);
         if (levelChunkTicks != null) {
             levelChunkTicks.setOnTickAdded(null);
         }
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     @Override
     public void schedule(ScheduledTick<T> tick) {
+        try { lock.lock(); // Canvas - lock
         long packedChunkPos = ChunkPos.asLong(tick.pos());
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(packedChunkPos);
         if (levelChunkTicks == null) {
@@ -77,23 +_,19 @@
         } else {
             levelChunkTicks.schedule(tick);
         }
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     public void tick(long gameTime, int maxAllowedTicks, BiConsumer<BlockPos, T> ticker) {
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("collect");
-        this.collectTicks(gameTime, maxAllowedTicks, profilerFiller);
-        profilerFiller.popPush("run");
-        profilerFiller.incrementCounter("ticksToRun", this.toRunThisTick.size());
+        try { lock.lock(); // Canvas - lock
+        this.collectTicks(gameTime, maxAllowedTicks);
         this.runCollectedTicks(ticker);
-        profilerFiller.popPush("cleanup");
         this.cleanupAfterTick();
-        profilerFiller.pop();
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
-    private void collectTicks(long gameTime, int maxAllowedTicks, ProfilerFiller profiler) {
+    private void collectTicks(long gameTime, int maxAllowedTicks) {
         this.sortContainersToTick(gameTime);
-        profiler.incrementCounter("containersToTick", this.containersToTick.size());
         this.drainContainers(gameTime, maxAllowedTicks);
         this.rescheduleLeftoverContainers();
     }
@@ -148,7 +_,9 @@
     }
 
     private void updateContainerScheduling(ScheduledTick<T> tick) {
+        try { lock.lock(); // Canvas - lock
         this.nextTickForContainer.put(ChunkPos.asLong(tick.pos()), tick.triggerTick());
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     private void drainFromCurrentContainer(Queue<LevelChunkTicks<T>> containersToTick, LevelChunkTicks<T> levelChunkTicks, long gameTime, int maxAllowedTicks) {
@@ -191,7 +_,7 @@
     }
 
     private void cleanupAfterTick() {
-        this.toRunThisTick.clear();
+        // this.toRunThisTick.clear(); // Canvas - avoid useless clear, we poll this during the tick so it's always empty
         this.containersToTick.clear();
         this.alreadyRunThisTick.clear();
         this.toRunThisTickSet.clear();
@@ -199,14 +_,18 @@
 
     @Override
     public boolean hasScheduledTick(BlockPos pos, T type) {
+        try { lock.lock(); // Canvas - lock
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(ChunkPos.asLong(pos));
         return levelChunkTicks != null && levelChunkTicks.hasScheduledTick(pos, type);
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     @Override
     public boolean willTickThisTick(BlockPos pos, T type) {
+        try { lock.lock(); // Canvas - lock
         this.calculateTickSetIfNeeded();
         return this.toRunThisTickSet.contains(ScheduledTick.probe(type, pos));
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     private void calculateTickSetIfNeeded() {
@@ -233,6 +_,7 @@
     }
 
     public void clearArea(BoundingBox area) {
+        try { lock.lock(); // Canvas - lock
         Predicate<ScheduledTick<T>> predicate = scheduledTick -> area.isInside(scheduledTick.pos());
         this.forContainersInArea(area, (pos, container) -> {
             ScheduledTick<T> scheduledTick = container.peek();
@@ -248,6 +_,7 @@
         });
         this.alreadyRunThisTick.removeIf(predicate);
         this.toRunThisTick.removeIf(predicate);
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     public void copyArea(BoundingBox area, Vec3i offset) {
@@ -255,6 +_,7 @@
     }
 
     public void copyAreaFrom(LevelTicks<T> levelTicks, BoundingBox area, Vec3i offset) {
+        try { lock.lock(); // Canvas - lock
         List<ScheduledTick<T>> list = new ArrayList<>();
         Predicate<ScheduledTick<T>> predicate = scheduledTick -> area.isInside(scheduledTick.pos());
         levelTicks.alreadyRunThisTick.stream().filter(predicate).forEach(list::add);
@@ -274,11 +_,14 @@
                 )
             )
         );
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     @Override
     public int count() {
+        try { lock.lock(); // Canvas - lock
         return this.allContainers.values().stream().mapToInt(TickAccess::count).sum();
+        } finally { lock.unlock(); } // Canvas - lock
     }
 
     @FunctionalInterface
