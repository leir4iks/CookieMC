--- a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -160,6 +_,7 @@
         }
 
         this.vanillaRender.buffer = colors.array(); // Paper - Use Vanilla map renderer when possible
+        this.setDirty(false); // Canvas - reset dirty flag when loading maps from disk
     }
 
     public static MapItemSavedData createFresh(
@@ -177,7 +_,7 @@
         return new MapItemSavedData(0, 0, scale, false, false, locked, dimension);
     }
 
-    public MapItemSavedData locked() {
+    public synchronized MapItemSavedData locked() { // Canvas - make map data thread-safe
         MapItemSavedData mapItemSavedData = new MapItemSavedData(
             this.centerX, this.centerZ, this.scale, this.trackingPosition, this.unlimitedTracking, true, this.dimension
         );
@@ -188,7 +_,7 @@
         return mapItemSavedData;
     }
 
-    public MapItemSavedData scaled() {
+    public synchronized MapItemSavedData scaled() { // Canvas - make map data thread-safe
         return createFresh(this.centerX, this.centerZ, (byte)Mth.clamp(this.scale + 1, 0, 4), this.trackingPosition, this.unlimitedTracking, this.dimension);
     }
 
@@ -197,7 +_,7 @@
         return itemStack -> itemStack == stack || itemStack.is(stack.getItem()) && Objects.equals(mapId, itemStack.get(DataComponents.MAP_ID));
     }
 
-    public void tickCarriedBy(Player player, ItemStack mapStack) {
+    public synchronized void tickCarriedBy(Player player, ItemStack mapStack) { // Canvas - make map data thread-safe
         if (!this.carriedByPlayers.containsKey(player)) {
             MapItemSavedData.HoldingPlayer holdingPlayer = new MapItemSavedData.HoldingPlayer(player);
             this.carriedByPlayers.put(player, holdingPlayer);
@@ -211,6 +_,7 @@
 
         for (int i = 0; i < this.carriedBy.size(); i++) {
             MapItemSavedData.HoldingPlayer holdingPlayer1 = this.carriedBy.get(i);
+            if (holdingPlayer1 == null) continue; // Canvas - threaded tracker
             Player player1 = holdingPlayer1.player;
             String string = player1.getName().getString();
             if (!player1.isRemoved() && (player1.getInventory().contains(predicate) || mapStack.isFramed())) {
@@ -383,7 +_,7 @@
     }
 
     @Nullable
-    public Packet<?> getUpdatePacket(MapId mapId, Player player) {
+    public synchronized Packet<?> getUpdatePacket(MapId mapId, Player player) { // Canvas - make map data thread-safe
         MapItemSavedData.HoldingPlayer holdingPlayer = this.carriedByPlayers.get(player);
         return holdingPlayer == null ? null : holdingPlayer.nextUpdatePacket(mapId);
     }
@@ -392,20 +_,21 @@
     // Paper start - Fix unnecessary map data saves
         this.setColorsDirty(x, z, true);
     }
-    public void setColorsDirty(int x, int z, boolean markFileDirty) {
-        if (markFileDirty) this.setDirty();
+    public synchronized void setColorsDirty(int x, int z, boolean markFileDirty) { // Canvas - make map data thread-safe
+        if (markFileDirty) this.setDirty(); // Canvas - make map data thread-safe
     // Paper end - Fix unnecessary map data saves
 
         for (MapItemSavedData.HoldingPlayer holdingPlayer : this.carriedBy) {
             holdingPlayer.markColorsDirty(x, z);
         }
+        if (markFileDirty) this.setDirty(); // Canvas - make map data thread-safe
     }
 
-    public void setDecorationsDirty() {
+    public synchronized void setDecorationsDirty() { // Canvas - make map data thread-safe
         this.carriedBy.forEach(MapItemSavedData.HoldingPlayer::markDecorationsDirty);
     }
 
-    public MapItemSavedData.HoldingPlayer getHoldingPlayer(Player player) {
+    public synchronized MapItemSavedData.HoldingPlayer getHoldingPlayer(Player player) { // Canvas - make map data thread-safe
         MapItemSavedData.HoldingPlayer holdingPlayer = this.carriedByPlayers.get(player);
         if (holdingPlayer == null) {
             holdingPlayer = new MapItemSavedData.HoldingPlayer(player);
@@ -416,7 +_,7 @@
         return holdingPlayer;
     }
 
-    public boolean toggleBanner(LevelAccessor accessor, BlockPos pos) {
+    public synchronized boolean toggleBanner(LevelAccessor accessor, BlockPos pos) { // Canvas - make map data thread-safe
         double d = pos.getX() + 0.5;
         double d1 = pos.getZ() + 0.5;
         int i = 1 << this.scale;
@@ -424,7 +_,7 @@
         double d3 = (d1 - this.centerZ) / i;
         int i1 = 63;
         if (d2 >= -63.0 && d3 >= -63.0 && d2 <= 63.0 && d3 <= 63.0) {
-            MapBanner mapBanner = MapBanner.fromWorld(accessor, pos);
+            MapBanner mapBanner = accessor.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) == null || !io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(accessor.getMinecraftWorld(), pos) ? null : MapBanner.fromWorld(accessor, pos); // Canvas - make map data thread-safe
             if (mapBanner == null) {
                 return false;
             }
@@ -446,7 +_,7 @@
         return false;
     }
 
-    public void checkBanners(BlockGetter reader, int x, int z) {
+    public synchronized void checkBanners(BlockGetter reader, int x, int z) { // Canvas - make map data thread-safe
         Iterator<MapBanner> iterator = this.bannerMarkers.values().iterator();
 
         while (iterator.hasNext()) {
@@ -466,13 +_,13 @@
         return this.bannerMarkers.values();
     }
 
-    public void removedFromFrame(BlockPos pos, int entityId) {
+    public synchronized void removedFromFrame(BlockPos pos, int entityId) { // Canvas - make map data thread-safe
         this.removeDecoration(getFrameKey(entityId));
         this.frameMarkers.remove(MapFrame.frameId(pos));
         this.setDirty();
     }
 
-    public boolean updateColor(int x, int z, byte color) {
+    public synchronized boolean updateColor(int x, int z, byte color) { // Canvas - make map data thread-safe
         byte b = this.colors[x + z * 128];
         if (b != color) {
             this.setColor(x, z, color);
@@ -482,12 +_,12 @@
         }
     }
 
-    public void setColor(int x, int z, byte color) {
+    public synchronized void setColor(int x, int z, byte color) { // Canvas - make map data thread-safe
         this.colors[x + z * 128] = color;
         this.setColorsDirty(x, z);
     }
 
-    public boolean isExplorationMap() {
+    public synchronized boolean isExplorationMap() { // Canvas - make map data thread-safe
         for (MapDecoration mapDecoration : this.decorations.values()) {
             if (mapDecoration.type().value().explorationMapElement()) {
                 return true;
@@ -497,7 +_,7 @@
         return false;
     }
 
-    public void addClientSideDecorations(List<MapDecoration> decorations) {
+    public synchronized void addClientSideDecorations(List<MapDecoration> decorations) { // Canvas - make map data thread-safe
         this.decorations.clear();
         this.trackedDecorationCount = 0;
 
@@ -514,7 +_,7 @@
         return this.decorations.values();
     }
 
-    public boolean isTrackedCountOverLimit(int trackedCount) {
+    public synchronized boolean isTrackedCountOverLimit(int trackedCount) { // Canvas - make map data thread-safe
         return this.trackedDecorationCount >= trackedCount;
     }
 
@@ -669,11 +_,13 @@
         }
 
         public void applyToMap(MapItemSavedData savedData) {
+            synchronized (savedData) { // Canvas - make map data thread-safe
             for (int i = 0; i < this.width; i++) {
                 for (int i1 = 0; i1 < this.height; i1++) {
                     savedData.setColor(this.startX + i, this.startY + i1, this.mapColors[i + i1 * this.width]);
                 }
             }
+            } // Canvas - make map data thread-safe
         }
     }
 
