--- a/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -25,12 +_,28 @@
 import net.minecraft.util.ZeroBitStorage;
 
 public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainerRO<T> {
+
+    // Canvas start - faster chunk serialization
+    private static final ThreadLocal<short[]> CACHED_ARRAY_4096 = ThreadLocal.withInitial(() -> new short[4096]);
+    private static final ThreadLocal<short[]> CACHED_ARRAY_64 = ThreadLocal.withInitial(() -> new short[64]);
+    private Optional<LongStream> asOptional(long[] data) {
+        return Optional.of(Arrays.stream(data));
+    }
+    private short[] getOrCreate(int size) {
+        return switch (size) {
+            case 64 -> CACHED_ARRAY_64.get();
+            case 4096 -> CACHED_ARRAY_4096.get();
+            default -> new short[size];
+        };
+    }
+    // Canvas end
+
     private static final int MIN_PALETTE_BITS = 0;
     private final PaletteResize<T> dummyPaletteResize = (bits, objectAdded) -> 0;
     public final IdMap<T> registry;
     private final T @org.jetbrains.annotations.Nullable [] presetValues; // Paper - Anti-Xray - Add preset values
     public volatile PalettedContainer.Data<T> data; // Paper - optimise collisions - public
-    private final PalettedContainer.Strategy strategy;
+    public final PalettedContainer.Strategy strategy; // Canvas - private -> public
     //private final ThreadingDetector threadingDetector = new ThreadingDetector("PalettedContainer"); // Paper - unused
 
     public void acquire() {
@@ -168,6 +_,11 @@
         this.registry = registry;
         this.data = this.createOrReuseData(null, 0);
         this.data.palette.idFor(palette);
+        // Canvas start
+        if (palette != null) {
+            this.data.palette.valueFor(0);
+        } else throw new RuntimeException("Attempted to build PalettedContainer with a null palette!");
+        // Canvas end
         this.updateData(this.data); // Paper - optimise palette reads
     }
 
@@ -222,7 +_,7 @@
         return this.getAndSet(this.strategy.getIndex(x, y, z), state);
     }
 
-    private T getAndSet(int index, T state) {
+    private synchronized T getAndSet(int index, T state) { // Canvas - why isn't this synchronized too?
         // Paper start - optimise palette reads
         final int paletteIdx = this.data.palette.idFor(state);
         final PalettedContainer.Data<T> data = this.data;
@@ -344,28 +_,54 @@
     public synchronized PalettedContainerRO.PackedData<T> pack(IdMap<T> registry, PalettedContainer.Strategy strategy) { // Paper - synchronize
         this.acquire();
 
-        PalettedContainerRO.PackedData var12;
+        // Canvas start - faster chunk serialization
+        Optional<LongStream> data = Optional.empty();
+        List<T> elements = null;
         try {
-            HashMapPalette<T> hashMapPalette = new HashMapPalette<>(registry, this.data.storage.getBits(), this.dummyPaletteResize);
-            int size = strategy.size();
-            int[] ints = new int[size];
-            this.data.storage.unpack(ints);
-            swapPalette(ints, id -> hashMapPalette.idFor(this.data.palette.valueFor(id)));
-            int i = strategy.calculateBitsForSerialization(registry, hashMapPalette.getSize());
-            Optional<LongStream> optional;
-            if (i != 0) {
-                SimpleBitStorage simpleBitStorage = new SimpleBitStorage(i, size, ints);
-                optional = Optional.of(Arrays.stream(simpleBitStorage.getRaw()));
-            } else {
-                optional = Optional.empty();
-            }
-
-            var12 = new PalettedContainerRO.PackedData<>(hashMapPalette.getEntries(), optional);
+            // The palette that will be serialized
+            io.canvasmc.canvas.util.LithiumHashPalette<T> hashPalette = null;
+
+            final Palette<T> palette = this.data.palette();
+            final BitStorage storage = this.data.storage();
+            if (storage instanceof ZeroBitStorage || palette.getSize() == 1) {
+                // If the palette only contains one entry, don't attempt to repack it.
+                elements = List.of(palette.valueFor(0));
+            } else if (palette instanceof io.canvasmc.canvas.util.LithiumHashPalette<T> lithiumHashPalette) {
+                hashPalette = lithiumHashPalette;
+            }
+
+            if (elements == null) {
+                io.canvasmc.canvas.util.LithiumHashPalette<T> compactedPalette = new io.canvasmc.canvas.util.LithiumHashPalette<>(registry, storage.getBits(), this.dummyPaletteResize);
+                short[] array = this.getOrCreate(strategy.size());
+
+                storage.compact(this.data.palette(), compactedPalette, array);
+
+                // If the palette didn't change during compaction, do a simple copy of the data array
+                if (hashPalette != null && hashPalette.getSize() == compactedPalette.getSize() && storage.getBits() == strategy.calculateBitsForSerialization(registry, hashPalette.getSize())) { // paletteSize can de-sync from palette - see https://github.com/CaffeineMC/lithium-fabric/issues/279
+                    data = this.asOptional(storage.getRaw().clone());
+                    elements = hashPalette.getElements();
+                } else {
+                    int bits = strategy.calculateBitsForSerialization(registry, compactedPalette.getSize());
+                    if (bits != 0) {
+                        // Re-pack the integer array as the palette has changed size
+                        SimpleBitStorage copy = new SimpleBitStorage(bits, array.length);
+                        for (int i = 0; i < array.length; ++i) {
+                            copy.set(i, array[i]);
+                        }
+
+                        // We don't need to clone the data array as we are the sole owner of it
+                        data = this.asOptional(copy.getRaw());
+                    }
+
+                    elements = compactedPalette.getElements();
+                }
+            }
         } finally {
             this.release();
         }
 
-        return var12;
+        return new PalettedContainerRO.PackedData<>(elements, data);
+        // Canvas end
     }
 
     private static <T> void swapPalette(int[] bits, IntUnaryOperator operator) {
@@ -392,6 +_,12 @@
     public boolean maybeHas(Predicate<T> predicate) {
         return this.data.palette.maybeHas(predicate);
     }
+    // Canvas start - maybeHasOrCatch
+
+    public boolean maybeHasOrCatch(Predicate<T> predicate, @org.jetbrains.annotations.NotNull T defaultValue) {
+        return this.data.palette.maybeHasOrCatch(predicate, defaultValue);
+    }
+    // Canvas end
 
     @Override
     public PalettedContainer<T> copy() {
@@ -405,13 +_,33 @@
 
     @Override
     public void count(PalettedContainer.CountConsumer<T> countConsumer) {
-        if (this.data.palette.getSize() == 1) {
-            countConsumer.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
-        } else {
-            Int2IntOpenHashMap map = new Int2IntOpenHashMap();
-            this.data.storage.getAll(id -> map.addTo(id, 1));
-            map.int2IntEntrySet().forEach(idEntry -> countConsumer.accept(this.data.palette.valueFor(idEntry.getIntKey()), idEntry.getIntValue()));
-        }
+        // Canvas start - faster chunk serialization
+        int len = this.data.palette().getSize();
+
+        // Do not allocate huge arrays if we're using a large palette
+        if (len > 4096) {
+            // VanillaCopy
+            if (this.data.palette.getSize() == 1) {
+                countConsumer.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
+            } else {
+                Int2IntOpenHashMap map = new Int2IntOpenHashMap();
+                this.data.storage.getAll(id -> map.addTo(id, 1));
+                map.int2IntEntrySet().forEach(idEntry -> countConsumer.accept(this.data.palette.valueFor(idEntry.getIntKey()), idEntry.getIntValue()));
+            }
+        }
+
+        short[] counts = new short[len];
+
+        this.data.storage().getAll(i -> counts[i]++);
+
+        for (int i = 0; i < counts.length; i++) {
+            T obj = this.data.palette().valueFor(i);
+
+            if (obj != null) {
+                countConsumer.accept(obj, counts[i]);
+            }
+        }
+        // Canvas end
     }
 
     record Configuration<T>(Palette.Factory factory, int bits) {
@@ -432,7 +_,7 @@
 
         private final PalettedContainer.Configuration<T> configuration;
         private final BitStorage storage;
-        private final Palette<T> palette;
+        public final Palette<T> palette; // Canvas - private -> public
 
         private T[] moonrise$palette;
 
