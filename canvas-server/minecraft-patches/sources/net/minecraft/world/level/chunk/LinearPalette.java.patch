--- a/net/minecraft/world/level/chunk/LinearPalette.java
+++ b/net/minecraft/world/level/chunk/LinearPalette.java
@@ -10,9 +_,13 @@
 public class LinearPalette<T> implements Palette<T>, ca.spottedleaf.moonrise.patches.fast_palette.FastPalette<T> { // Paper - optimise palette reads
     private final IdMap<T> registry;
     private final T[] values;
+    // Canvas start - Optimize LinearPalette
+    private final int[] byteSizes;
+    private final int[] idCache; // Cached registry IDs for values
+    // Canvas end - Optimize LinearPalette
     private final PaletteResize<T> resizeHandler;
     private final int bits;
-    private int size;
+    private volatile int size; // Canvas - volatile
 
     // Paper start - optimise palette reads
     @Override
@@ -24,23 +_,40 @@
     private LinearPalette(IdMap<T> registry, int bits, PaletteResize<T> resizeHandler, List<T> values) {
         this.registry = registry;
         this.values = (T[])(new Object[1 << bits]);
+        // Canvas start - Optimize LinearPalette
+        this.idCache = new int[1 << bits];
+        this.byteSizes = new int[1 << bits]; // Initialize byteSizes
+        // Canvas end - Optimize LinearPalette
         this.bits = bits;
         this.resizeHandler = resizeHandler;
         Validate.isTrue(values.size() <= this.values.length, "Can't initialize LinearPalette of size %d with %d entries", this.values.length, values.size());
 
         for (int i = 0; i < values.size(); i++) {
-            this.values[i] = values.get(i);
+            // Canvas start - Optimize LinearPalette
+            T value = values.get(i);
+            this.values[i] = value;
+            int id = registry.getId(value);
+            this.idCache[i] = id;
+            this.byteSizes[i] = VarInt.getByteSize(id); // Precompute byte size
+            // Canvas end - Optimize LinearPalette
         }
 
         this.size = values.size();
     }
 
-    private LinearPalette(IdMap<T> registry, T[] values, PaletteResize<T> resizeHandler, int bits, int size) {
+    private LinearPalette(IdMap<T> registry, T[] values, int[] idCache, PaletteResize<T> resizeHandler, int bits, int size) { // Canvas - Optimize LinearPalette
         this.registry = registry;
         this.values = values;
+        this.idCache = idCache; // Canvas - Optimize LinearPalette
         this.resizeHandler = resizeHandler;
         this.bits = bits;
         this.size = size;
+        // Canvas start - Optimize LinearPalette
+        this.byteSizes = new int[idCache.length];
+        for (int i = 0; i < idCache.length; i++) {
+            this.byteSizes[i] = VarInt.getByteSize(idCache[i]);
+        }
+        // Canvas end - Optimize LinearPalette
     }
 
     public static <A> Palette<A> create(int bits, IdMap<A> registry, PaletteResize<A> resizeHandler, List<A> values) {
@@ -49,8 +_,11 @@
 
     @Override
     public int idFor(T state) {
-        for (int i = 0; i < this.size; i++) {
-            if (this.values[i] == state) {
+        // Canvas start - threadsafe
+        final T[] values = this.values;
+        for (int i = 0; i < values.length; i++) {
+            if (values[i] == state) {
+        // Canvas end
                 return i;
             }
         }
@@ -58,6 +_,11 @@
         int ix = this.size;
         if (ix < this.values.length) {
             this.values[ix] = state;
+            // Canvas start - Optimize LinearPalette
+            int id = registry.getId(state);
+            this.idCache[ix] = id;
+            this.byteSizes[ix] = VarInt.getByteSize(id); // Cache byte size
+            // Canvas end - Optimize LinearPalette
             this.size++;
             return ix;
         } else {
@@ -67,8 +_,14 @@
 
     @Override
     public boolean maybeHas(Predicate<T> filter) {
-        for (int i = 0; i < this.size; i++) {
-            if (filter.test(this.values[i])) {
+        // Canvas start - threadsafe
+        final T[] values = this.values;
+        final int currentSize = this.size;
+
+        for (int i = 0; i < currentSize; i++) {
+            T value = values[i];
+            if (value != null && filter.test(value)) {
+        // Canvas end
                 return true;
             }
         }
@@ -77,7 +_,7 @@
     }
 
     @Override
-    public T valueFor(int id) {
+    public synchronized T valueFor(int id) { // Canvas - synchronize
         if (id >= 0 && id < this.size) {
             return this.values[id];
         } else {
@@ -90,7 +_,12 @@
         this.size = buffer.readVarInt();
 
         for (int i = 0; i < this.size; i++) {
-            this.values[i] = this.registry.byIdOrThrow(buffer.readVarInt());
+            // Canvas start - Optimize LinearPalette
+            int id = buffer.readVarInt();
+            this.values[i] = this.registry.byIdOrThrow(id);
+            this.idCache[i] = id;
+            this.byteSizes[i] = VarInt.getByteSize(id); // Precompute during read
+            // Canvas end - Optimize LinearPalette
         }
     }
 
@@ -99,17 +_,18 @@
         buffer.writeVarInt(this.size);
 
         for (int i = 0; i < this.size; i++) {
-            buffer.writeVarInt(this.registry.getId(this.values[i]));
+            buffer.writeVarInt(this.idCache[i]); // Canvas - Optimize LinearPalette - Use cached ID
         }
     }
 
     @Override
     public int getSerializedSize() {
-        int byteSize = VarInt.getByteSize(this.getSize());
-
-        for (int i = 0; i < this.getSize(); i++) {
-            byteSize += VarInt.getByteSize(this.registry.getId(this.values[i]));
+        // Canvas start - Optimize LinearPalette
+        int byteSize = VarInt.getByteSize(this.size);
+        for (int i = 0; i < this.size; i++) {
+            byteSize += this.byteSizes[i]; // Use cached byte sizes
         }
+        // Canvas end - Optimize LinearPalette
 
         return byteSize;
     }
@@ -121,6 +_,56 @@
 
     @Override
     public Palette<T> copy(PaletteResize<T> resizeHandler) {
-        return new LinearPalette<>(this.registry, (T[])((Object[])this.values.clone()), resizeHandler, this.bits, this.size);
+        // Canvas start - Optimize LinearPalette
+        // Special case for empty palette - fastest possible return
+        if (this.size == 0) {
+            return new LinearPalette<>(this.registry, (T[]) new Object[1], new int[1], resizeHandler, this.bits, 0);
+        }
+
+        // For small sizes, allocate exact-sized arrays and use direct assignment
+        if (this.size <= 4) {
+            @SuppressWarnings("unchecked")
+            T[] valuesCopy = (T[]) new Object[this.size];
+            int[] idCacheCopy = new int[this.size];
+
+            // Unrolled loop eliminates loop overhead for small arrays
+            switch (this.size) {
+                case 4:
+                    valuesCopy[3] = this.values[3];
+                    idCacheCopy[3] = this.idCache[3];
+                    // Fall through
+                case 3:
+                    valuesCopy[2] = this.values[2];
+                    idCacheCopy[2] = this.idCache[2];
+                    // Fall through
+                case 2:
+                    valuesCopy[1] = this.values[1];
+                    idCacheCopy[1] = this.idCache[1];
+                    // Fall through
+                case 1:
+                    valuesCopy[0] = this.values[0];
+                    idCacheCopy[0] = this.idCache[0];
+            }
+
+            return new LinearPalette<>(this.registry, valuesCopy, idCacheCopy, resizeHandler, this.bits, this.size);
+        }
+
+        // For larger arrays, use optimized bulk operations
+        @SuppressWarnings("unchecked")
+        T[] valuesCopy = (T[]) new Object[this.size];
+        int[] idCacheCopy = new int[this.size];
+
+        System.arraycopy(this.values, 0, valuesCopy, 0, this.size);
+        System.arraycopy(this.idCache, 0, idCacheCopy, 0, this.size);
+
+        return new LinearPalette<>(
+            this.registry,
+            valuesCopy,
+            idCacheCopy,
+            resizeHandler,
+            this.bits,
+            this.size
+        );
+        // Canvas end - Optimize LinearPalette
     }
 }
