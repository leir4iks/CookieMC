--- a/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
@@ -10,6 +_,7 @@
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
@@ -157,7 +_,7 @@
         BlockPos blockPos = findValidSpawnInChunk(chunk);
         if (blockPos == null) {
             BlockPos blockPos1 = BlockPos.containing(vec3.x + 0.5, 75.0, vec3.z + 0.5);
-            LOGGER.debug("Failed to find a suitable block to teleport to, spawning an island on {}", blockPos1);
+            LOGGER.info("Failed to find a suitable block to teleport to, spawning an island on {}", blockPos1); // Canvas - debug -> info
             level.registryAccess()
                 .lookup(Registries.CONFIGURED_FEATURE)
                 .flatMap(registry -> registry.get(EndFeatures.END_ISLAND))
@@ -166,7 +_,7 @@
                 );
             blockPos = blockPos1;
         } else {
-            LOGGER.debug("Found suitable block to teleport to: {}", blockPos);
+            LOGGER.info("Found suitable block to teleport to: {}", blockPos); // Canvas - debug -> info
         }
 
         return findTallestBlock(level, blockPos, 16, true);
@@ -185,12 +_,21 @@
             LOGGER.debug("Skipping forward past empty chunk at {}", vec31);
         }
 
-        LOGGER.debug("Found chunk at {}", vec31);
+        LOGGER.info("Found chunk at {}", vec31); // Canvas - debug -> info
         return vec31;
     }
 
     private static boolean isChunkEmpty(ServerLevel level, Vec3 pos) {
-        return getChunk(level, pos).getHighestFilledSectionIndex() == -1;
+        // Canavs start - Threaded Regions
+        int chunkX = Mth.floor(pos.x / 16.0);
+        int chunkZ = Mth.floor(pos.z / 16.0);
+        level.chunkSource.updateRegionTicket(chunkX, chunkZ, true, TicketType.END_GATEWAY);
+        try {
+            return getChunk(level, pos).getHighestFilledSectionIndex() == -1;
+        } finally {
+            level.chunkSource.updateRegionTicket(chunkX, chunkZ, false, TicketType.END_GATEWAY);
+        }
+        // Canvas end
     }
 
     private static BlockPos findTallestBlock(BlockGetter level, BlockPos pos, int radius, boolean allowBedrock) {
@@ -201,7 +_,20 @@
                 if (i != 0 || i1 != 0 || allowBedrock) {
                     for (int y = level.getMaxY(); y > (blockPos == null ? level.getMinY() : blockPos.getY()); y--) {
                         BlockPos blockPos1 = new BlockPos(pos.getX() + i, y, pos.getZ() + i1);
-                        BlockState blockState = level.getBlockState(blockPos1);
+                        // Canvas start
+                        int chunkX = blockPos1.getX() >> 4;
+                        int chunkZ = blockPos1.getZ() >> 4;
+                        BlockState blockState = null;
+                        if (level instanceof ServerLevel serverLevel) {
+                            serverLevel.chunkSource.updateRegionTicket(chunkX, chunkZ, true, TicketType.END_GATEWAY);
+                            try {
+                                blockState = level.getBlockState(blockPos1);
+                            } finally {
+                                serverLevel.chunkSource.updateRegionTicket(chunkX, chunkZ, false, TicketType.END_GATEWAY);
+                            }
+                        }
+                        if (blockState == null) continue;
+                        // Canvas end
                         if (blockState.isCollisionShapeFullBlock(level, blockPos1) && (allowBedrock || !blockState.is(Blocks.BEDROCK))) {
                             blockPos = blockPos1;
                             break;
@@ -246,7 +_,7 @@
     }
 
     private static void spawnGatewayPortal(ServerLevel level, BlockPos pos, EndGatewayConfiguration config) {
-        Feature.END_GATEWAY.place(config, level, level.getChunkSource().getGenerator(), RandomSource.create(), pos);
+        Feature.END_GATEWAY.place(config, level, level.getChunkSource().getGenerator(), level.random, pos); // Canvas - reduce RandomSource instances
     }
 
     @Override
