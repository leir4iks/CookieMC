--- a/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -3,6 +_,10 @@
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.event.ShapeUpdateEvent;
+import io.canvasmc.canvas.region.ServerRegions;
+import io.canvasmc.canvas.util.TPSCalculator;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap;
 import java.util.Arrays;
 import java.util.Collections;
@@ -26,7 +_,9 @@
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.resources.DependantName;
 import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.Mth;
@@ -84,6 +_,7 @@
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.craftbukkit.block.data.CraftBlockData;
 
 public abstract class BlockBehaviour implements FeatureElement {
     protected static final Direction[] UPDATE_SHAPE_ORDER = new Direction[]{
@@ -347,13 +_,21 @@
     protected void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
     }
 
+    // Canvas start
+    private float lagCompensation(float original, Player player) {
+        if (!Config.INSTANCE.lagCompensation.enabled || !Config.INSTANCE.lagCompensation.blockBreakingAcceleration) return original;
+        if (player.level().isClientSide) return original;
+        return original * TPSCalculator.MAX_TPS / (float) ServerRegions.getTickData((ServerLevel) player.level()).tpsCalculator.getMostAccurateTPS(); // Canvas - Threaded Regions
+    }
+
+    // Canvas end
     protected float getDestroyProgress(BlockState state, Player player, BlockGetter level, BlockPos pos) {
         float destroySpeed = state.getDestroySpeed(level, pos);
         if (destroySpeed == -1.0F) {
-            return 0.0F;
+            return lagCompensation(0.0F, player); // Canvas
         } else {
             int i = player.hasCorrectToolForDrops(state) ? 30 : 100;
-            return player.getDestroySpeed(state) / destroySpeed / i;
+            return lagCompensation(player.getDestroySpeed(state) / destroySpeed / i, player); // Canvas
         }
     }
 
@@ -470,6 +_,7 @@
         private boolean emptyCollisionShape;
         private boolean emptyConstantCollisionShape;
         private VoxelShape constantCollisionShape;
+        public net.minecraft.world.level.pathfinder.PathType pathType; // Canvas - cache path type
 
         private static void initCaches(final VoxelShape shape, final boolean neighbours) {
             ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)shape).moonrise$isFullBlock();
@@ -637,6 +_,11 @@
             // Paper end - optimise collisions
         }
 
+        // Canvas start - cache path type
+        public void initPathType() {
+            this.pathType = net.minecraft.world.level.pathfinder.WalkNodeEvaluator.getPathTypeFromState(this.asState());
+        }
+        // Canvas end
         public Block getBlock() {
             return this.owner;
         }
@@ -925,7 +_,16 @@
             BlockState neighborState,
             RandomSource random
         ) {
-            return this.getBlock().updateShape(this.asState(), level, scheduledTickAccess, pos, direction, neighborPos, neighborState, random);
+            // Canvas start - ShapeUpdateEvent
+            CraftBlockData provided = this.createCraftBlockData();
+            ShapeUpdateEvent blockShapeEvent = new ShapeUpdateEvent(provided);
+            boolean canceled = !blockShapeEvent.callEvent();
+            provided = (CraftBlockData) blockShapeEvent.getBlock();
+            if (canceled) {
+                return provided.getState();
+            }
+            return this.getBlock().updateShape(provided.getState(), level, scheduledTickAccess, pos, direction, neighborPos, neighborState, random);
+            // Canvas end
         }
 
         public boolean isPathfindable(PathComputationType type) {
@@ -1047,8 +_,10 @@
         static final class Cache {
             private static final Direction[] DIRECTIONS = Direction.values();
             private static final int SUPPORT_TYPE_COUNT = SupportType.values().length;
+            private static final SupportType[] SUPPORT_TYPE_VALUES = SupportType.values(); // Canvas - cache
+            private static final Direction.Axis[] DIRECTION_AXIS_VALUES = Direction.Axis.values(); // Canvas - cache
             protected final VoxelShape collisionShape;
-            protected final boolean largeCollisionShape;
+            protected boolean largeCollisionShape = false; // Canvas - mutable && default false
             private final boolean[] faceSturdy;
             protected final boolean isCollisionShapeFullBlock;
 
@@ -1064,12 +_,18 @@
                         )
                     );
                 } else {
-                    this.largeCollisionShape = Arrays.stream(Direction.Axis.values())
-                        .anyMatch(dir -> this.collisionShape.min(dir) < 0.0 || this.collisionShape.max(dir) > 1.0);
+                    // Canvas start - remove streams
+                    for (Direction.Axis axis : DIRECTION_AXIS_VALUES) { // Canvas - cache
+                        if (this.collisionShape.min(axis) < 0.0 || this.collisionShape.max(axis) > 1.0) {
+                            this.largeCollisionShape = true;
+                            break;
+                        }
+                    }
+                    // Canvas end
                     this.faceSturdy = new boolean[DIRECTIONS.length * SUPPORT_TYPE_COUNT];
 
                     for (Direction direction : DIRECTIONS) {
-                        for (SupportType supportType : SupportType.values()) {
+                        for (SupportType supportType : SUPPORT_TYPE_VALUES) { // Canvas - cache
                             this.faceSturdy[getFaceSupportIndex(direction, supportType)] = supportType.isSupporting(
                                 state, EmptyBlockGetter.INSTANCE, BlockPos.ZERO, direction
                             );
