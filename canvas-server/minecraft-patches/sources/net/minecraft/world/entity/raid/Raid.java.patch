--- a/net/minecraft/world/entity/raid/Raid.java
+++ b/net/minecraft/world/entity/raid/Raid.java
@@ -121,7 +_,7 @@
     public final ServerBossEvent raidEvent = new ServerBossEvent(RAID_NAME_COMPONENT, BossEvent.BossBarColor.RED, BossEvent.BossBarOverlay.NOTCHED_10);
     private int postRaidTicks;
     private int raidCooldownTicks;
-    private final RandomSource random = RandomSource.create();
+    // private final RandomSource random = RandomSource.create(); // Canvas - reduce RandomSource instances
     public final int numGroups;
     private Raid.RaidStatus status;
     private int celebrationTicks;
@@ -222,7 +_,7 @@
     private Predicate<ServerPlayer> validPlayer() {
         return player -> {
             BlockPos blockPos = player.blockPosition();
-            return player.isAlive() && player.serverLevel().getRaidAt(blockPos) == this;
+            return io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(player) && player.isAlive() && player.serverLevel().getRaidAt(blockPos) == this; // Canvas - threadsafe raids
         };
     }
 
@@ -276,8 +_,16 @@
         this.raidEvent.removeAllPlayers();
         this.status = Raid.RaidStatus.STOPPED;
     }
+    // Canvas start
+    private boolean isBarDirty;
 
     public void tick(ServerLevel level) {
+        if (this.isBarDirty) {
+            this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
+
+            this.isBarDirty = false;
+        }
+    // Canvas end
         if (!this.isStopped()) {
             if (this.status == Raid.RaidStatus.ONGOING) {
                 boolean flag = this.active;
@@ -397,12 +_,21 @@
                         for (UUID uuid : this.heroesOfTheVillage) {
                             Entity entity = level.getEntity(uuid);
                             if (entity instanceof LivingEntity livingEntity && !entity.isSpectator()) {
-                                livingEntity.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.raidOmenLevel - 1, false, false, true));
+                                // livingEntity.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.raidOmenLevel - 1, false, false, true)); // Canvas - fix off region raid heros
                                 if (livingEntity instanceof ServerPlayer serverPlayer) {
-                                    serverPlayer.awardStat(Stats.RAID_WIN);
-                                    CriteriaTriggers.RAID_WIN.trigger(serverPlayer);
+                                    // serverPlayer.awardStat(Stats.RAID_WIN); // Canvas - fix off region raid heros
+                                    // CriteriaTriggers.RAID_WIN.trigger(serverPlayer); // Canvas - fix off region raid heros
                                     winners.add(serverPlayer.getBukkitEntity()); // CraftBukkit
                                 }
+                                // Canvas start - fix off region raid heros
+                                livingEntity.getBukkitEntity().taskScheduler.schedule((LivingEntity lv) -> {
+                                    lv.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.raidOmenLevel - 1, false, false, true));
+                                    if (lv instanceof ServerPlayer serverPlayer) {
+                                        serverPlayer.awardStat(Stats.RAID_WIN);
+                                        CriteriaTriggers.RAID_WIN.trigger(serverPlayer);
+                                    }
+                                }, null, 1L);
+                                // Canvas end
                             }
                         }
                         org.bukkit.craftbukkit.event.CraftEventFactory.callRaidFinishEvent(level, this, winners); // CraftBukkit
@@ -501,9 +_,9 @@
         float f = 13.0F;
         int i = 64;
         Collection<ServerPlayer> players = this.raidEvent.getPlayers();
-        long randomLong = this.random.nextLong();
+        long randomLong = level.random.nextLong(); // Canvas - reduce RandomSource instances
 
-        for (ServerPlayer serverPlayer : level.players()) {
+        for (ServerPlayer serverPlayer : level.getLocalPlayers()) { // Canvas - Threaded Regions
             Vec3 vec3 = serverPlayer.position();
             Vec3 vec31 = Vec3.atCenterOf(pos);
             double squareRoot = Math.sqrt((vec31.x - vec3.x) * (vec31.x - vec3.x) + (vec31.z - vec3.z) * (vec31.z - vec3.z));
@@ -525,7 +_,7 @@
 
         for (Raid.RaiderType raiderType : Raid.RaiderType.VALUES) {
             int i1 = this.getDefaultNumSpawns(raiderType, i, shouldSpawnBonusGroup)
-                + this.getPotentialBonusSpawns(raiderType, this.random, i, currentDifficultyAt, shouldSpawnBonusGroup);
+                + this.getPotentialBonusSpawns(raiderType, level.random, i, currentDifficultyAt, shouldSpawnBonusGroup); // Canvas - reduce RandomSource instances
             int i2 = 0;
 
             for (int i3 = 0; i3 < i1; i3++) {
@@ -588,7 +_,7 @@
     }
 
     public void updateBossbar() {
-        this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
+        this.isBarDirty = true; // Canvas
     }
 
     public float getHealthOfLivingRaiders() {
@@ -687,6 +_,11 @@
     }
 
     private boolean addWaveMob(ServerLevel level, int wave, Raider raider) {
+        // Canvas start - threadsafe raids
+        if (!this.ownsRaid(level)) {
+            return false;
+        }
+        // Canvas end
         return this.addWaveMob(level, wave, raider, true);
     }
 
@@ -806,6 +_,13 @@
     public java.util.Collection<Raider> getRaiders() {
         return this.groupRaiderMap.values().stream().flatMap(Set::stream).collect(java.util.stream.Collectors.toSet());
     }
+    // Canvas start - threadsafe raids
+
+    public boolean ownsRaid(ServerLevel world) {
+        BlockPos center = this.getCenter();
+        return center != null && io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(world, center.getX() >> 4, center.getZ() >> 4, 8);
+    }
+    // Canvas end
     // CraftBukkit end
 
     static enum RaidStatus implements StringRepresentable {
