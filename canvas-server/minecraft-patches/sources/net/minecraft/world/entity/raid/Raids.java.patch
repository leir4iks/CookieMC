--- a/net/minecraft/world/entity/raid/Raids.java
+++ b/net/minecraft/world/entity/raid/Raids.java
@@ -35,16 +_,16 @@
                 Raids.RaidWithId.CODEC
                     .listOf()
                     .optionalFieldOf("raids", List.of())
-                    .forGetter(raids -> raids.raidMap.int2ObjectEntrySet().stream().map(Raids.RaidWithId::from).toList()),
-                Codec.INT.fieldOf("next_id").forGetter(raids -> raids.nextId),
+                    .forGetter(raids -> raids.raidMap.entrySet().stream().map(Raids.RaidWithId::from).toList()), // Canvas - threadsafe raids
+                Codec.INT.fieldOf("next_id").forGetter(raids -> raids.nextAvailableID.get()), // Canvas - threadsafe raids
                 Codec.INT.fieldOf("tick").forGetter(raids -> raids.tick)
             )
             .apply(instance, Raids::new)
     );
     public static final SavedDataType<Raids> TYPE = new SavedDataType<>("raids", Raids::new, CODEC, DataFixTypes.SAVED_DATA_RAIDS);
     public static final SavedDataType<Raids> TYPE_END = new SavedDataType<>("raids_end", Raids::new, CODEC, DataFixTypes.SAVED_DATA_RAIDS);
-    public final Int2ObjectMap<Raid> raidMap = new Int2ObjectOpenHashMap<>();
-    private int nextId = 1;
+    public final java.util.Map<Integer, Raid> raidMap = new java.util.concurrent.ConcurrentHashMap<>(); // Canvas - threadsafe raids
+    private final java.util.concurrent.atomic.AtomicInteger nextAvailableID = new java.util.concurrent.atomic.AtomicInteger(); // Canvas - threadsafe raids
     private int tick;
 
     public static SavedDataType<Raids> getType(Holder<DimensionType> dimension) {
@@ -52,6 +_,7 @@
     }
 
     public Raids() {
+        this.nextAvailableID.set(1); // Canvas - threadsafe raids
         this.setDirty();
     }
 
@@ -61,7 +_,7 @@
             raidWithId.raid.idOrNegativeOne = raidWithId.id; // Paper - expose id of raids while method is kept around as deprecated for removal
         }
 
-        this.nextId = nextId;
+        this.nextAvailableID.set(nextId); // Canvas - threadsafe raids
         this.tick = tick;
     }
 
@@ -71,17 +_,25 @@
     }
 
     public OptionalInt getId(Raid raid) {
-        for (Entry<Raid> entry : this.raidMap.int2ObjectEntrySet()) {
+        for (java.util.Map.Entry<Integer, Raid> entry : this.raidMap.entrySet()) { // Canvas - threadsafe raids
             if (entry.getValue() == raid) {
-                return OptionalInt.of(entry.getIntKey());
+                return OptionalInt.of(entry.getKey().intValue()); // Canvas - threadsafe raids
             }
         }
 
         return OptionalInt.empty();
     }
 
-    public void tick(ServerLevel level) {
+    // Canvas start - threadsafe raids
+    public void globalTick() {
         this.tick++;
+        if (this.tick % 200 == 0) {
+            this.setDirty();
+        }
+    }
+
+    public void tick(ServerLevel level) {
+    // Canvas end
         // Purpur start - Raid cooldown setting
         if (level.purpurConfig.raidCooldownSeconds != 0 && this.tick % 20 == 0) {
             com.google.common.collect.ImmutableMap.copyOf(playerCooldowns).forEach((uuid, i) -> {
@@ -97,6 +_,11 @@
 
         while (iterator.hasNext()) {
             Raid raid = iterator.next();
+            // Canvas start - threadsafe raids
+            if (!raid.ownsRaid(level)) {
+                continue;
+            }
+            // Canvas end
             if (level.getGameRules().getBoolean(GameRules.RULE_DISABLE_RAIDS)) {
                 raid.stop();
             }
@@ -109,9 +_,7 @@
             }
         }
 
-        if (this.tick % 200 == 0) {
-            this.setDirty();
-        }
+        // Canvas - threadsafe raids
 
         DebugPackets.sendRaids(level, this.raidMap.values());
     }
@@ -126,7 +_,7 @@
             return null;
         } else {
             ServerLevel serverLevel = player.serverLevel();
-            if (serverLevel.getGameRules().getBoolean(GameRules.RULE_DISABLE_RAIDS)) {
+            if (serverLevel.getGameRules().getBoolean(GameRules.RULE_DISABLE_RAIDS) || !io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(player) || !io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(serverLevel, pos.getX() >> 4, pos.getZ() >> 4, 8) || !io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(serverLevel, player.chunkPosition().x, player.chunkPosition().z, 8)) { // Canvas - Threaded Regions
                 return null;
             } else {
                 DimensionType dimensionType = serverLevel.dimensionType();
@@ -169,8 +_,8 @@
                         if (serverLevel.purpurConfig.raidCooldownSeconds != 0) playerCooldowns.put(player.getUUID(), serverLevel.purpurConfig.raidCooldownSeconds); // Purpur - Raid cooldown setting
 
                         if (!raid.isStarted() && !this.raidMap.containsValue(raid)) {
-                            this.raidMap.put(this.getUniqueId(), raid);
-                            raid.idOrNegativeOne = this.nextId; // Paper - expose id of raids while method is kept around as deprecated for removal
+                            int id = this.getUniqueId(); this.raidMap.put(id, raid); // Canvas - Threaded Regions
+                            raid.idOrNegativeOne = id; // Paper - expose id of raids while method is kept around as deprecated for removal // Canvas - Threaded Regions
                         }
                         // CraftBukkit end
                         raid.absorbRaidOmen(player);
@@ -193,15 +_,20 @@
     }
 
     private int getUniqueId() {
-        return ++this.nextId;
+        return this.nextAvailableID.incrementAndGet(); // Canvas - threadsafe raids
     }
 
     @Nullable
-    public Raid getNearbyRaid(BlockPos pos, int distance) {
+    public Raid getNearbyRaid(ServerLevel world, BlockPos pos, int distance) { // Canvas - threadsafe raids
         Raid raid = null;
         double d = distance;
 
         for (Raid raid1 : this.raidMap.values()) {
+            // Canvas start - threadsafe raids
+            if (!raid1.ownsRaid(world)) {
+                continue;
+            }
+            // Canvas end
             double d1 = raid1.getCenter().distSqr(pos);
             if (raid1.isActive() && d1 < d) {
                 raid = raid1;
@@ -218,8 +_,8 @@
                 .apply(instance, Raids.RaidWithId::new)
         );
 
-        public static Raids.RaidWithId from(Entry<Raid> entry) {
-            return new Raids.RaidWithId(entry.getIntKey(), entry.getValue());
+        public static Raids.RaidWithId from(java.util.Map.Entry<Integer, Raid> entry) { // Canvas - threadsafe raids
+            return new Raids.RaidWithId(entry.getKey().intValue(), entry.getValue()); // Canvas - threadsafe raids
         }
     }
 }
