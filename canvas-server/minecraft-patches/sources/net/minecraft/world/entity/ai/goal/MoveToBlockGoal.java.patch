--- a/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
@@ -1,6 +_,8 @@
 package net.minecraft.world.entity.ai.goal;
 
 import java.util.EnumSet;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.PathfinderMob;
 import net.minecraft.world.level.LevelReader;
@@ -41,14 +_,74 @@
         this.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.JUMP));
     }
 
+    // Canvas start - Async target finding
+    protected boolean poll() {
+        if (!(this.mob.getGoalCtx().result() instanceof BlockPos blockPos1)) return false;
+        if (!this.mob.level().hasChunkAt(blockPos1)
+            || !this.mob.isWithinRestriction(blockPos1)
+            || !this.isValidTarget(this.mob.level(), blockPos1)) {
+            return false;
+        }
+        this.blockPos = blockPos1;
+        this.mob.movingTarget = blockPos1 == BlockPos.ZERO ? null : blockPos1;
+        return true;
+    }
+
+    protected boolean findNearestBlockAsync() {
+        // Canvas start - Async target finding
+        if (!io.canvasmc.canvas.Config.INSTANCE.entities.asyncTargetFinding.searchBlock) {
+            return findNearestBlock();
+        }
+        // Canvas end - Async target finding
+        final var mob = this.mob;
+        final var ctx = mob.getGoalCtx();
+        if (!ctx.state) return false;
+        final var serverLevel = getServerLevel(mob);
+        final TypeToCheck ty = this.typeToCheck();
+        final net.minecraft.world.level.block.Block toRemove;
+        if (this instanceof RemoveBlockGoal removeBlockGoal) {
+            toRemove = removeBlockGoal.blockToRemove;
+        } else {
+            toRemove = null;
+        }
+        final int verticalSearchStart = this.verticalSearchStart;
+        final int searchRange = this.searchRange;
+        final int verticalSearchRange = this.verticalSearchRange;
+        final BlockPos blockPos = mob.blockPosition();
+        final float restrictRadius = mob.getRestrictRadius();
+        final BlockPos restrictCenter = mob.getRestrictCenter();
+        ctx.wake = () -> findNearestBlockAsync(ty, toRemove, mob, serverLevel, verticalSearchStart, searchRange, verticalSearchRange, blockPos, restrictRadius, restrictCenter);
+        return false;
+    }
+
+    protected enum TypeToCheck {
+        CatLie,
+        CatSit,
+        Drowned,
+        FoxEat,
+        RaidGarden,
+        RemoveBlock,
+        Strider,
+        TurtleToWater,
+        TurtleLay,
+        Unknown,
+    }
+    // Canvas end - Async target finding
+
     @Override
     public boolean canUse() {
+        if (Config.INSTANCE.entities.cramming.reduceEntityMoveWhenCrammed && (ServerRegions.getTickData(this.mob.level().level()).nonThreadsafeRandom.nextInt(100) >= 10 && !this.mob.canTickMoveOptimized())) return false; // Canvas - reduce movement when crammed
+        // Canvas start - Async target finding
+        if (poll()) {
+            return true;
+        }
+        // Canvas end - Async target finding
         if (this.nextStartTick > 0) {
             this.nextStartTick--;
             return false;
         } else {
             this.nextStartTick = this.nextStartTick(this.mob);
-            return this.findNearestBlock();
+            return this.findNearestBlockAsync(); // Canvas - Async target finding
         }
     }
 
@@ -119,6 +_,7 @@
                 for (int i4 = 0; i4 <= i3; i4 = i4 > 0 ? -i4 : 1 - i4) {
                     for (int i5 = i4 < i3 && i4 > -i3 ? i3 : 0; i5 <= i3; i5 = i5 > 0 ? -i5 : 1 - i5) {
                         mutableBlockPos.setWithOffset(blockPos, i4, i2 - 1, i5);
+                        if (!this.mob.level().hasChunkAt(mutableBlockPos)) continue; // Canvas - block goal does not load chunks - if this block isn't loaded, continue
                         if (this.mob.isWithinRestriction(mutableBlockPos) && this.isValidTarget(this.mob.level(), mutableBlockPos)) {
                             this.blockPos = mutableBlockPos;
                             this.mob.movingTarget = mutableBlockPos == BlockPos.ZERO ? null : mutableBlockPos.immutable(); // Paper
@@ -132,5 +_,108 @@
         return false;
     }
 
+    // Canvas start - Async target finding
+    protected static @javax.annotation.Nullable BlockPos findNearestBlockAsync(
+        final TypeToCheck ty,
+        @org.jetbrains.annotations.Nullable final net.minecraft.world.level.block.Block toRemove,
+        final PathfinderMob mob,
+        final net.minecraft.server.level.ServerLevel serverLevel,
+        final int verticalSearchStart,
+        final int searchRange,
+        final int verticalSearchRange,
+        final BlockPos blockPos,
+        final float restrictRadius,
+        final BlockPos restrictCenter
+    ) {
+        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        for (int i2 = verticalSearchStart; i2 <= verticalSearchRange; i2 = i2 > 0 ? -i2 : 1 - i2) {
+            for (int i3 = 0; i3 < searchRange; i3++) {
+                for (int i4 = 0; i4 <= i3; i4 = i4 > 0 ? -i4 : 1 - i4) {
+                    for (int i5 = i4 < i3 && i4 > -i3 ? i3 : 0; i5 <= i3; i5 = i5 > 0 ? -i5 : 1 - i5) {
+                        mutableBlockPos.setWithOffset(blockPos, i4, i2 - 1, i5);
+                        if (!serverLevel.hasChunkAt(mutableBlockPos)) continue;
+                        if (isWithinRestriction(restrictRadius, restrictCenter, mutableBlockPos)
+                            && isValidTargetAsync(ty, toRemove, mob, serverLevel, mutableBlockPos)) {
+                            return mutableBlockPos.immutable();
+                        }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private static boolean isWithinRestriction(float restrictRadius, BlockPos restrictCenter, BlockPos pos) {
+        return restrictRadius == -1.0F || restrictCenter.distSqr(pos) < restrictRadius * restrictRadius;
+    }
+    // Canvas end - Async target finding
+
     protected abstract boolean isValidTarget(LevelReader level, BlockPos pos);
+
+    // Canvas start - Async target finding
+    protected TypeToCheck typeToCheck() {
+        return TypeToCheck.Unknown;
+    }
+
+    private static boolean isValidTargetAsync(
+        TypeToCheck type,
+        @org.jetbrains.annotations.Nullable net.minecraft.world.level.block.Block blockToRemoveTy,
+        PathfinderMob mob,
+        LevelReader level,
+        BlockPos pos
+    ) {
+        switch (type) {
+            case CatLie -> {
+                return level.isEmptyBlock(pos.above()) && level.getBlockState(pos).is(net.minecraft.tags.BlockTags.BEDS);
+            }
+            case CatSit -> {
+                if (!level.isEmptyBlock(pos.above())) {
+                    return false;
+                } else {
+                    var blockState = level.getBlockState(pos);
+                    return blockState.is(net.minecraft.world.level.block.Blocks.CHEST)
+                        ? net.minecraft.world.level.block.entity.ChestBlockEntity.getOpenCount(level, pos) < 1
+                        : blockState.is(net.minecraft.world.level.block.Blocks.FURNACE) && blockState.getValue(net.minecraft.world.level.block.FurnaceBlock.LIT)
+                        || blockState.is(net.minecraft.tags.BlockTags.BEDS, state -> state.getOptionalValue(net.minecraft.world.level.block.BedBlock.PART).map(bedPart -> bedPart != net.minecraft.world.level.block.state.properties.BedPart.HEAD).orElse(true));
+                }
+            }
+            case Drowned -> {
+                BlockPos blockPos = pos.above();
+                return level.isEmptyBlock(blockPos) && level.isEmptyBlock(blockPos.above()) && level.getBlockState(pos).entityCanStandOn(level, pos, mob);
+            }
+            case FoxEat -> {
+                var blockState = level.getBlockState(pos);
+                return blockState.is(net.minecraft.world.level.block.Blocks.SWEET_BERRY_BUSH) && blockState.getValue(net.minecraft.world.level.block.SweetBerryBushBlock.AGE) >= 2 || net.minecraft.world.level.block.CaveVines.hasGlowBerries(blockState);
+            }
+            case RaidGarden -> {
+                var blockState = level.getBlockState(pos);
+                if (blockState.is(net.minecraft.world.level.block.Blocks.FARMLAND)) {
+                    blockState = level.getBlockState(pos.above());
+                    return blockState.getBlock() instanceof net.minecraft.world.level.block.CarrotBlock carrot && carrot.isMaxAge(blockState);
+                } else {
+                    return false;
+                }
+
+            }
+            case RemoveBlock -> {
+                var chunk = level.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4); // Paper - Prevent AI rules from loading chunks
+                return chunk != null
+                    && chunk.getBlockState(pos).is(blockToRemoveTy)
+                    && chunk.getBlockState(pos.above()).isAir()
+                    && chunk.getBlockState(pos.above(2)).isAir();
+            }
+            case Strider -> {
+                return level.getBlockState(pos).is(net.minecraft.world.level.block.Blocks.LAVA) && level.getBlockState(pos.above()).isPathfindable(net.minecraft.world.level.pathfinder.PathComputationType.LAND);
+            }
+            case TurtleToWater -> {
+                return level.getBlockState(pos).is(net.minecraft.world.level.block.Blocks.WATER);
+            }
+            case TurtleLay -> {
+                return level.isEmptyBlock(pos.above()) && net.minecraft.world.level.block.TurtleEggBlock.isSand(level, pos);
+            }
+            case Unknown -> throw new IllegalStateException();
+            case null -> throw new IllegalStateException();
+        }
+        // Canvas end - Async target finding
+    }
 }
