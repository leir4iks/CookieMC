--- a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -28,6 +_,13 @@
 public class AcquirePoi {
     public static final int SCAN_RANGE = 48;
 
+    // Canvas start - reduce acquire POI for stuck entities
+    private static void addAdditionalTimeToMutableLongIfMobIsStuck(MutableLong mutableLong, net.minecraft.server.level.ServerLevel level, PathfinderMob mob) {
+        long stuckEntityAdditionalWaitTime = io.canvasmc.canvas.Config.INSTANCE.entities.acquirePoiForStuckEntity;
+        mutableLong.add(stuckEntityAdditionalWaitTime <= 0L ? 0L : mob.getNavigation().isStuck() ? stuckEntityAdditionalWaitTime : 0L);
+    }
+    // Canvas end
+
     public static BehaviorControl<PathfinderMob> create(
         Predicate<Holder<PoiType>> acquirablePois,
         MemoryModuleType<GlobalPos> acquiringMemory,
@@ -65,12 +_,13 @@
                             return false;
                         } else if (mutableLong.getValue() == 0L) {
                             mutableLong.setValue(level.getGameTime() + level.random.nextInt(20));
+                            addAdditionalTimeToMutableLongIfMobIsStuck(mutableLong, level, mob); // Canvas - reduce acquire POI for stuck entities
                             return false;
                         } else if (level.getGameTime() < mutableLong.getValue()) {
                             return false;
                         } else {
                             mutableLong.setValue(time + 20L + level.getRandom().nextInt(20));
-                            if (mob.getNavigation().isStuck()) mutableLong.add(200); // Paper - Perf: Wait an additional 10s to check again if they're stuck // TODO Modifies Vanilla behavior, add config option
+                            addAdditionalTimeToMutableLongIfMobIsStuck(mutableLong, level, mob); // Paper - Perf: Wait an additional 10s to check again if they're stuck // TODO Modifies Vanilla behavior, add config option // Canvas - reduce acquire POI for stuck entities
                             PoiManager poiManager = level.getPoiManager();
                             map.long2ObjectEntrySet().removeIf(entry -> !entry.getValue().isStillValid(time));
                             Predicate<BlockPos> predicate1 = pos -> {
@@ -94,21 +_,20 @@
                                 }
                             }
                             // Paper end - optimise POI access
-                            Path path = findPathToPois(mob, set);
-                            if (path != null && path.canReach()) {
-                                BlockPos target = path.getTarget();
-                                poiManager.getType(target).ifPresent(holder -> {
-                                    poiManager.take(acquirablePois, (holder1, blockPos) -> blockPos.equals(target), target, 1);
-                                    memoryAccessor.set(GlobalPos.of(level.dimension(), target));
-                                    entityEventId.ifPresent(id -> level.broadcastEntityEvent(mob, id));
-                                    map.clear();
-                                    DebugPackets.sendPoiTicketCountPacket(level, target);
+                            // Canvas start - Async path processing
+                            if (io.canvasmc.canvas.Config.INSTANCE.entities.pathfinding.enableThreadedPathfinding) {
+                                // await on path async
+                                Path possiblePath = findPathToPois(mob, set);
+
+                                // wait on the path to be processed
+                                io.canvasmc.canvas.entity.pathfinding.AsyncPathProcessor.awaitProcessing(level, possiblePath, path -> { // Canvas - Threaded Regions
+                                    processPath(acquirablePois, entityEventId, map, memoryAccessor, level, mob, time, poiManager, set, path);
                                 });
                             } else {
-                                for (Pair<Holder<PoiType>, BlockPos> pair : set) {
-                                    map.computeIfAbsent(pair.getSecond().asLong(), l -> new AcquirePoi.JitteredLinearRetry(level.random, time));
-                                }
+                                Path path = findPathToPois(mob, set);
+                                processPath(acquirablePois, entityEventId, map, memoryAccessor, level, mob, time, poiManager, set, path);
                             }
+                            // Canvas end - Async path processing
 
                             return true;
                         }
@@ -119,6 +_,34 @@
             ? oneShot
             : BehaviorBuilder.create(instance -> instance.group(instance.absent(existingAbsentMemory)).apply(instance, memoryAccessor -> oneShot));
     }
+
+    // Canvas start - Async path processing
+    private static void processPath(Predicate<Holder<PoiType>> acquirablePois,
+                                    Optional<Byte> entityEventId,
+                                    Long2ObjectMap<JitteredLinearRetry> map,
+                                    net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor<com.mojang.datafixers.kinds.Const.Mu<com.mojang.datafixers.util.Unit>, GlobalPos> memoryAccessor,
+                                    ServerLevel level,
+                                    PathfinderMob mob,
+                                    long time,
+                                    PoiManager poiManager,
+                                    Set<Pair<Holder<PoiType>, BlockPos>> set,
+                                    @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            poiManager.getType(target).ifPresent(holder -> {
+                poiManager.take(acquirablePois, (holder1, blockPos) -> blockPos.equals(target), target, 1);
+                memoryAccessor.set(GlobalPos.of(level.dimension(), target));
+                entityEventId.ifPresent(id -> level.broadcastEntityEvent(mob, id));
+                map.clear();
+                DebugPackets.sendPoiTicketCountPacket(level, target);
+            });
+        } else {
+            for (Pair<Holder<PoiType>, BlockPos> pair : set) {
+                map.computeIfAbsent(pair.getSecond().asLong(), l -> new AcquirePoi.JitteredLinearRetry(level.random, time));
+            }
+        }
+    }
+    // Canvas end - Async path processing
 
     @Nullable
     public static Path findPathToPois(Mob mob, Set<Pair<Holder<PoiType>, BlockPos>> poiPositions) {
