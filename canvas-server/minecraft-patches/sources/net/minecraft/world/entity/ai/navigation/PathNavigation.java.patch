--- a/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -5,13 +_,13 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.Config;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Vec3i;
 import net.minecraft.network.protocol.game.DebugPackets;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.util.Mth;
-import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.ai.attributes.Attributes;
@@ -96,11 +_,20 @@
     }
 
     public void recomputePath() {
-        if (this.level.getGameTime() - this.timeLastRecompute > 20L) {
+        if (this.tick - this.timeLastRecompute > 20L) { // Canvas - use tick for path recomputing
             if (this.targetPos != null) {
                 this.path = null;
                 this.path = this.createPath(this.targetPos, this.reachRange);
-                this.timeLastRecompute = this.level.getGameTime();
+                // Canvas start
+                if ((this.mob).lithium$isRegisteredToWorld()) {
+                    if (this.path == null) {
+                        ((ServerLevel) this.level).lithium$setNavigationInactive(this.mob);
+                    } else {
+                        ((ServerLevel) this.level).lithium$setNavigationActive(this.mob);
+                    }
+                }
+                // Canvas end
+                this.timeLastRecompute = this.tick; // Canvas - use tick for path recomputing
                 this.hasDelayedRecomputation = false;
             }
         } else {
@@ -169,6 +_,10 @@
             return null;
         } else if (!this.canUpdatePath()) {
             return null;
+        // Canvas start - catch early if it's still processing these positions let it keep processing
+        } else if (this.path instanceof io.canvasmc.canvas.entity.pathfinding.AsyncPath asyncPath && !asyncPath.isProcessed() && asyncPath.hasSameProcessingPositions(targets)) {
+            return this.path;
+        // Canvas end
         } else if (this.path != null && !this.path.isDone() && targets.contains(this.targetPos)) {
             return this.path;
         } else {
@@ -189,18 +_,33 @@
                 }
             }
             // Paper end - EntityPathfindEvent
-            ProfilerFiller profilerFiller = Profiler.get();
-            profilerFiller.push("pathfind");
             BlockPos blockPos = offsetUpward ? this.mob.blockPosition().above() : this.mob.blockPosition();
             int i = (int)(followRange + regionOffset);
             PathNavigationRegion pathNavigationRegion = new PathNavigationRegion(this.level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i));
             Path path = this.pathFinder.findPath(pathNavigationRegion, this.mob, targets, followRange, accuracy, this.maxVisitedNodesMultiplier);
-            profilerFiller.pop();
+            // Canvas start async path processing
+            if (Config.INSTANCE.entities.pathfinding.enableThreadedPathfinding) {
+                // assign early a target position. most calls will only have 1 position
+                if (!targets.isEmpty()) this.targetPos = targets.iterator().next();
+
+                io.canvasmc.canvas.entity.pathfinding.AsyncPathProcessor.awaitProcessing((ServerLevel) this.level, path, processedPath -> { // Canvas - Threaded Regions
+                    // check that processing didn't take so long that we calculated a new path
+                    if (processedPath != this.path) return;
+
+                    if (processedPath != null && processedPath.getTarget() != null) {
+                        this.targetPos = processedPath.getTarget();
+                        this.reachRange = accuracy;
+                        this.resetStuckTimeout();
+                    }
+                });
+            } else {
+            // Canvas end
             if (path != null && path.getTarget() != null) {
                 this.targetPos = path.getTarget();
                 this.reachRange = accuracy;
                 this.resetStuckTimeout();
             }
+            } // Canvas - async path processing
 
             return path;
         }
@@ -221,7 +_,7 @@
 
     public boolean moveTo(Entity entity, double speed) {
         // Paper start - Perf: Optimise pathfinding
-        if (this.pathfindFailures > 10 && this.path == null && net.minecraft.server.MinecraftServer.currentTick < this.lastFailure + 40) {
+        if (this.pathfindFailures > 10 && this.path == null && this.tick < this.lastFailure + 40) { // Canvas - Threaded Regions
             return false;
         }
         // Paper end - Perf: Optimise pathfinding
@@ -233,7 +_,7 @@
             return true;
         } else {
             this.pathfindFailures++;
-            this.lastFailure = net.minecraft.server.MinecraftServer.currentTick;
+            this.lastFailure = this.tick; // Canvas - Threaded Regions
             return false;
         }
         // Paper end - Perf: Optimise pathfinding
@@ -242,6 +_,7 @@
     public boolean moveTo(@Nullable Path pathentity, double speed) {
         if (pathentity == null) {
             this.path = null;
+            updateListeningState2(path, speed); // Canvas
             return false;
         } else {
             if (!pathentity.sameAs(this.path)) {
@@ -249,21 +_,36 @@
             }
 
             if (this.isDone()) {
+                updateListeningState2(path, speed); // Canvas
                 return false;
             } else {
-                this.trimPath();
-                if (this.path.getNodeCount() <= 0) {
+                if (path.isProcessed()) this.trimPath(); // Canvas - only trim if processed
+                if (path.isProcessed() && this.path.getNodeCount() <= 0) { // Canvas - only check node count if processed
+                    updateListeningState2(path, speed); // Canvas
                     return false;
                 } else {
                     this.speedModifier = speed;
                     Vec3 tempMobPos = this.getTempMobPos();
                     this.lastStuckCheck = this.tick;
                     this.lastStuckCheckPos = tempMobPos;
+                    updateListeningState2(path, speed); // Canvas
                     return true;
                 }
             }
         }
     }
+    // Canvas start
+
+    private void updateListeningState2(Path path, double speed) {
+        if ((this.mob).lithium$isRegisteredToWorld()) {
+            if (this.path == null) {
+                ((ServerLevel) this.level).lithium$setNavigationInactive(this.mob);
+            } else {
+                ((ServerLevel) this.level).lithium$setNavigationActive(this.mob);
+            }
+        }
+    }
+    // Canvas end
 
     @Nullable
     public Path getPath() {
@@ -275,6 +_,7 @@
         if (this.hasDelayedRecomputation) {
             this.recomputePath();
         }
+        if (this.path != null && !this.path.isProcessed()) return; // Canvas - skip pathfinding if we're still processing
 
         if (!this.isDone()) {
             if (this.canUpdatePath()) {
@@ -304,6 +_,7 @@
     }
 
     protected void followThePath() {
+        if (!this.path.isProcessed()) return; // Canvas - skip if not processed
         Vec3 tempMobPos = this.getTempMobPos();
         this.maxDistanceToWaypoint = this.mob.getBbWidth() > 0.75F ? this.mob.getBbWidth() / 2.0F : 0.75F - this.mob.getBbWidth() / 2.0F;
         Vec3i nextNodePos = this.path.getNextNodePos();
@@ -402,6 +_,11 @@
 
     public void stop() {
         this.path = null;
+        // Canvas start
+        if ((this.mob).lithium$isRegisteredToWorld()) {
+            ((ServerLevel) this.level).lithium$setNavigationInactive(this.mob);
+        }
+        // Canvas end
     }
 
     protected abstract Vec3 getTempMobPos();
