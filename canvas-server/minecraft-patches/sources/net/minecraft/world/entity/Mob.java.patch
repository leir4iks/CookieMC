--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -2,6 +_,8 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Maps;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import java.util.HashSet;
 import java.util.List;
@@ -30,8 +_,6 @@
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
-import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.Container;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.DifficultyInstance;
@@ -136,7 +_,42 @@
     private BlockPos restrictCenter = BlockPos.ZERO;
     private float restrictRadius = -1.0F;
     public boolean aware = true; // CraftBukkit
+    // Canvas start
+    private PathNavigation registeredNavigation;
+
+    public boolean lithium$isRegisteredToWorld() {
+        return this.registeredNavigation != null;
+    }
+
+    public void lithium$setRegisteredToWorld(PathNavigation navigation) {
+        this.registeredNavigation = navigation;
+    }
+
+    public PathNavigation lithium$getRegisteredNavigation() {
+        return this.registeredNavigation;
+    }
+
+    public void lithium$updateNavigationRegistration() {
+        if (this.lithium$isRegisteredToWorld()) {
+            PathNavigation navigation = this.getNavigation();
+            if (this.registeredNavigation != navigation) {
+                ((ServerLevel) this.level()).lithium$setNavigationInactive((Mob) (Object) this);
+                this.registeredNavigation = navigation;
+
+                if (navigation.getPath() != null) {
+                    ((ServerLevel) this.level()).lithium$setNavigationActive((Mob) (Object) this);
+                }
+            }
+        }
+    }
+    // Canvas end
     public int ticksSinceLastInteraction; // Purpur - Entity lifespan
+    // Canvas start - Async target finding
+    public boolean tickingTarget;
+    public final io.canvasmc.canvas.entity.ai.Waker getGoalCtx() {
+        return tickingTarget ? this.targetSelector.ctx : this.goalSelector.ctx;
+    }
+    // Canvas end - Async target finding
 
     protected Mob(EntityType<? extends Mob> entityType, Level level) {
         super(entityType, level);
@@ -204,16 +_,24 @@
         return this.lookControl;
     }
 
+    int inactiveTickDisableCounter = 0; // Canvas - throttle inactive goal selector ticking
     // Paper start
     @Override
     public void inactiveTick() {
         super.inactiveTick();
-        if (this.goalSelector.inactiveTick()) {
+        if (Config.INSTANCE.entities.skipAiForNonAwareMob && !(this.isEffectiveAi() && this.aware)) return; // Canvas - skip AI during inactive ticks for non-aware mobs
+        boolean isThrottled = Config.INSTANCE.entities.throttleInactiveGoalSelectorTick && inactiveTickDisableCounter++ % 20 != 0; // Canvas - throttle inactive goal selector ticking
+        if (this.goalSelector.inactiveTick(this.activatedPriority, true) && !isThrottled) { // Canvas - throttle inactive goal selector ticking - DAB
             this.goalSelector.tick();
         }
-        if (this.targetSelector.inactiveTick()) {
+        if (this.targetSelector.inactiveTick(this.activatedPriority, true)) { // Canvas - pass activated priority
             this.targetSelector.tick();
         }
+        // Canvas start - Async target finding
+        if (io.canvasmc.canvas.Config.INSTANCE.entities.asyncTargetFinding.enabled) {
+            ServerRegions.getTickData(this.level().level()).asyncGoalExecutor.tickMob(this);
+        }
+        // Canvas end - Async target finding
     }
     // Paper end
 
@@ -318,14 +_,11 @@
     @Override
     public void baseTick() {
         super.baseTick();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("mobBaseTick");
         if (this.isAlive() && this.random.nextInt(1000) < this.ambientSoundTime++) {
             this.resetAmbientSoundTime();
             this.playAmbientSound();
         }
 
-        profilerFiller.pop();
         incrementTicksSinceLastInteraction(); // Purpur - Entity lifespan
     }
 
@@ -513,8 +_,6 @@
     @Override
     public void aiStep() {
         super.aiStep();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("looting");
         if (this.level() instanceof ServerLevel serverLevel
             && this.canPickUpLoot()
             && this.isAlive()
@@ -537,8 +_,6 @@
                 }
             }
         }
-
-        profilerFiller.pop();
     }
 
     protected Vec3i getPickupReach() {
@@ -702,12 +_,30 @@
         return false;
     }
 
+    public io.canvasmc.canvas.region.ServerRegions.WorldTickData temporaryRegionizedData = null; // Canvas - check eligible players for despawn checks
     @Override
     public void checkDespawn() {
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.shouldDespawnInPeaceful()) {
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
-            Entity nearestPlayer = this.level().findNearbyPlayer(this, -1.0, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper - Affects Spawning API
+            // Canvas start - check eligible players for despawn checks
+            Entity nearestPlayer = null;
+
+            if (this.level() instanceof ServerLevel serverLevel && this.temporaryRegionizedData != null) { // ensure that if something else calls this(like a plugin), we just run it like normal instead of cached, since we most likely won't have our temporary data
+                double minDist = Double.MAX_VALUE;
+                for (int i = 0; i < this.temporaryRegionizedData.eligibleDespawnCheckingPlayerCache.length; i++) {
+                    Player cachedPlayer = this.temporaryRegionizedData.eligibleDespawnCheckingPlayerCache[i];
+                    double d1 = cachedPlayer.distanceToSqr(this);
+                    if (d1 <= minDist) {
+                        minDist = d1;
+                        nearestPlayer = cachedPlayer;
+                    }
+                }
+            } else {
+                nearestPlayer = this.level().findNearbyPlayer(this, -1.0, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper - Affects Spawning API
+            }
+            this.temporaryRegionizedData = null;
+            // Canvas end
             if (nearestPlayer != null) {
                 // Paper start - Configurable despawn distances
                 final io.papermc.paper.configuration.WorldConfiguration.Entities.Spawning.DespawnRangePair despawnRangePair = this.level().paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory());
@@ -748,42 +_,30 @@
             return;
         }
         // Paper end - Allow nerfed mobs to jump and float
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("sensing");
         this.sensing.tick();
-        profilerFiller.pop();
         int i = this.tickCount + this.getId();
         if (i % 2 != 0 && this.tickCount > 1) {
-            profilerFiller.push("targetSelector");
+            if (this.targetSelector.inactiveTick(this.activatedPriority, false)) // Canvas - use this to alternate ticking
             this.targetSelector.tickRunningGoals(false);
-            profilerFiller.pop();
-            profilerFiller.push("goalSelector");
+            if (this.goalSelector.inactiveTick(this.activatedPriority, false)) // Canvas - use this to alternate ticking
             this.goalSelector.tickRunningGoals(false);
-            profilerFiller.pop();
         } else {
-            profilerFiller.push("targetSelector");
+            if (this.targetSelector.inactiveTick(this.activatedPriority, false)) // Canvas - use this to alternate ticking
             this.targetSelector.tick();
-            profilerFiller.pop();
-            profilerFiller.push("goalSelector");
+            if (this.goalSelector.inactiveTick(this.activatedPriority, false)) // Canvas - use this to alternate ticking
             this.goalSelector.tick();
-            profilerFiller.pop();
-        }
+        }
+        // Canvas start - Async target finding
+        if (io.canvasmc.canvas.Config.INSTANCE.entities.asyncTargetFinding.enabled) {
+            ServerRegions.getTickData(this.level().level()).asyncGoalExecutor.tickMob(this);
+        }
+        // Canvas end - Async target finding
 
-        profilerFiller.push("navigation");
         this.navigation.tick();
-        profilerFiller.pop();
-        profilerFiller.push("mob tick");
         this.customServerAiStep((ServerLevel)this.level());
-        profilerFiller.pop();
-        profilerFiller.push("controls");
-        profilerFiller.push("move");
         this.moveControl.tick();
-        profilerFiller.popPush("look");
         this.lookControl.tick();
-        profilerFiller.popPush("jump");
         this.jumpControl.tick();
-        profilerFiller.pop();
-        profilerFiller.pop();
         this.sendDebugPackets();
     }
 
@@ -1424,6 +_,7 @@
             // Paper end - Expand EntityUnleashEvent
         }
 
+        this.lithium$updateNavigationRegistration(); // Canvas
         return flag;
     }
 
