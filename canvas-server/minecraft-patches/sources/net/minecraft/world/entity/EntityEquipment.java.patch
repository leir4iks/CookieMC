--- a/net/minecraft/world/entity/EntityEquipment.java
+++ b/net/minecraft/world/entity/EntityEquipment.java
@@ -7,7 +_,7 @@
 import java.util.Map.Entry;
 import net.minecraft.world.item.ItemStack;
 
-public class EntityEquipment {
+public class EntityEquipment implements io.canvasmc.canvas.util.entity.EquipmentInfo, io.canvasmc.canvas.util.change_tracking.ChangeSubscriber.CountChangeSubscriber<ItemStack> { // Canvas - equipment tracking
     public static final Codec<EntityEquipment> CODEC = Codec.unboundedMap(EquipmentSlot.CODEC, ItemStack.CODEC).xmap(map -> {
         EnumMap<EquipmentSlot, ItemStack> map1 = new EnumMap<>(EquipmentSlot.class);
         map1.putAll((Map<? extends EquipmentSlot, ? extends ItemStack>)map);
@@ -18,6 +_,11 @@
         return map;
     });
     private final EnumMap<EquipmentSlot, ItemStack> items;
+    // Canvas start - equipment tracking
+    boolean shouldTickEnchantments = false;
+    ItemStack recheckEnchantmentForStack = null;
+    boolean hasUnsentEquipmentChanges = true;
+    // Canvas end - equipment tracking
 
     private EntityEquipment(EnumMap<EquipmentSlot, ItemStack> items) {
         this.items = items;
@@ -29,7 +_,11 @@
 
     public ItemStack set(EquipmentSlot slot, ItemStack stack) {
         stack.getItem().verifyComponentsAfterLoad(stack);
-        return Objects.requireNonNullElse(this.items.put(slot, stack), ItemStack.EMPTY);
+        // Canvas start - equipment tracking
+        ItemStack newStack = Objects.requireNonNullElse(this.items.put(slot, stack), ItemStack.EMPTY);
+        this.onEquipmentReplaced(this.get(slot), newStack);
+        return newStack;
+        // Canvas end - equipment tracking
     }
 
     public ItemStack get(EquipmentSlot slot) {
@@ -56,8 +_,21 @@
     }
 
     public void setAll(EntityEquipment equipment) {
+        this.onClear(); // Canvas - equipment tracking
         this.items.clear();
         this.items.putAll(equipment.items);
+        // Canvas start - equipment tracking
+        for (ItemStack newStack : this.items.values()) {
+            if (!newStack.isEmpty()) {
+                if (!this.shouldTickEnchantments) {
+                    this.shouldTickEnchantments = stackHasTickableEnchantment(newStack);
+                }
+                if (!newStack.isEmpty()) {
+                    newStack.lithium$subscribe(this, 0);
+                }
+            }
+        }
+        // Canvas end - equipment tracking
     }
 
     public void dropAll(LivingEntity entity) {
@@ -70,6 +_,7 @@
 
     public void clear() {
         this.items.replaceAll((equipmentSlot, itemStack) -> ItemStack.EMPTY);
+        this.onClear(); // Canvas - equipment tracking
     }
 
     // Paper start - EntityDeathEvent
@@ -78,4 +_,99 @@
         return this.items.containsKey(slot);
     }
     // Paper end - EntityDeathEvent
+
+    @Override
+    public boolean lithium$shouldTickEnchantments() {
+        this.processScheduledEnchantmentCheck(null);
+        return this.shouldTickEnchantments;
+    }
+
+    @Override
+    public boolean lithium$hasUnsentEquipmentChanges() {
+        return this.hasUnsentEquipmentChanges;
+    }
+
+    @Override
+    public void lithium$onEquipmentChangesSent() {
+        this.hasUnsentEquipmentChanges = false;
+    }
+
+    private void onClear() {
+        this.shouldTickEnchantments = false;
+        this.recheckEnchantmentForStack = null;
+        this.hasUnsentEquipmentChanges = true;
+
+        for (ItemStack oldStack : this.items.values()) {
+            if (!oldStack.isEmpty()) {
+                oldStack.lithium$unsubscribeWithData(this, 0);
+            }
+        }
+    }
+
+    private void onEquipmentReplaced(ItemStack oldStack, ItemStack newStack) {
+        if (!this.shouldTickEnchantments) {
+            if (this.recheckEnchantmentForStack == oldStack) {
+                this.recheckEnchantmentForStack = null;
+            }
+            this.shouldTickEnchantments = stackHasTickableEnchantment(newStack);
+        }
+
+        this.hasUnsentEquipmentChanges = true;
+
+        if (!oldStack.isEmpty()) {
+            oldStack.lithium$unsubscribeWithData(this, 0);
+        }
+        if (!newStack.isEmpty()) {
+            newStack.lithium$subscribe(this, 0);
+        }
+    }
+
+    private static boolean stackHasTickableEnchantment(ItemStack stack) {
+        if (!stack.isEmpty()) {
+            net.minecraft.world.item.enchantment.ItemEnchantments enchantments = stack.get(net.minecraft.core.component.DataComponents.ENCHANTMENTS);
+            if (enchantments != null && !enchantments.isEmpty()) {
+                for (net.minecraft.core.Holder<net.minecraft.world.item.enchantment.Enchantment> enchantmentEntry : enchantments.keySet()) {
+                    if (!enchantmentEntry.value().getEffects(net.minecraft.world.item.enchantment.EnchantmentEffectComponents.TICK).isEmpty()) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void lithium$notify(@org.jetbrains.annotations.Nullable ItemStack publisher, int zero) {
+        this.hasUnsentEquipmentChanges = true;
+
+        if (!this.shouldTickEnchantments) {
+            this.processScheduledEnchantmentCheck(publisher);
+            this.scheduleEnchantmentCheck(publisher);
+        }
+    }
+
+    private void scheduleEnchantmentCheck(@org.jetbrains.annotations.Nullable ItemStack toCheck) {
+        this.recheckEnchantmentForStack = toCheck;
+    }
+
+    private void processScheduledEnchantmentCheck(@org.jetbrains.annotations.Nullable ItemStack ignoredStack) {
+        if (this.recheckEnchantmentForStack != null && this.recheckEnchantmentForStack != ignoredStack) {
+            this.shouldTickEnchantments = stackHasTickableEnchantment(this.recheckEnchantmentForStack);
+            this.recheckEnchantmentForStack = null;
+        }
+    }
+
+    @Override
+    public void lithium$notifyCount(ItemStack publisher, int zero, int newCount) {
+        if (newCount == 0) {
+            publisher.lithium$unsubscribeWithData(this, zero);
+        }
+
+        this.onEquipmentReplaced(publisher, ItemStack.EMPTY);
+    }
+
+    @Override
+    public void lithium$forceUnsubscribe(ItemStack publisher, int zero) {
+        throw new UnsupportedOperationException();
+    }
 }
