--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -644,11 +_,19 @@
     }
 
     public final ChunkHolder vanillaChunkHolder;
+    // Canvas start - cache the long position in NewChunkHolders
+    private final long cachedLongPos;
+
+    public long getCachedLongPos() {
+        return cachedLongPos;
+    }
+    // Canvas end
 
     public NewChunkHolder(final ServerLevel world, final int chunkX, final int chunkZ, final ChunkTaskScheduler scheduler) {
         this.world = world;
         this.chunkX = chunkX;
         this.chunkZ = chunkZ;
+        this.cachedLongPos = ((long)chunkZ << 32) | (chunkX & 0xFFFFFFFFL); // Canvas - cache long pos
         this.scheduler = scheduler;
         this.vanillaChunkHolder = new ChunkHolder(
                 new ChunkPos(chunkX, chunkZ), ChunkHolderManager.MAX_TICKET_LEVEL, world,
@@ -1190,6 +_,7 @@
             for (int dz = -NEIGHBOUR_RADIUS; dz <= NEIGHBOUR_RADIUS; ++dz) {
                 for (int dx = -NEIGHBOUR_RADIUS; dx <= NEIGHBOUR_RADIUS; ++dx) {
                     final NewChunkHolder holder = (dx | dz) == 0 ? this : this.scheduler.chunkHolderManager.getChunkHolder(dx + this.chunkX, dz + this.chunkZ);
+                    if (holder == null) continue; // Canvas
                     if (loaded) {
                         if (holder.setNeighbourFullLoaded(-dx, -dz)) {
                             changedFullStatus.add(holder);
@@ -1214,6 +_,18 @@
 
     private void updateCurrentState(final FullChunkStatus to) {
         this.currentFullChunkStatus = to;
+        // Canvas start
+        if (to.isOrAfter(FullChunkStatus.BLOCK_TICKING)) {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.markBlockTicking(this);
+        } else {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.markNonBlockTickingIfPossible(this);
+        }
+        if (to.isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.markEntityTicking(this);
+        } else {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.markNonEntityTickingIfPossible(this);
+        }
+        // Canvas end
     }
 
     // only to be called on the main thread, no locks need to be held
@@ -1348,7 +_,7 @@
         return this.requestedGenStatus;
     }
 
-    private final Reference2ObjectOpenHashMap<ChunkStatus, List<Consumer<ChunkAccess>>> statusWaiters = new Reference2ObjectOpenHashMap<>();
+    private final Reference2ObjectMap<ChunkStatus, List<Consumer<ChunkAccess>>> statusWaiters = it.unimi.dsi.fastutil.objects.Reference2ObjectMaps.synchronize(new Reference2ObjectOpenHashMap<>()); // Canvas - synchronized
 
     void addStatusConsumer(final ChunkStatus status, final Consumer<ChunkAccess> consumer) {
         this.statusWaiters.computeIfAbsent(status, (final ChunkStatus keyInMap) -> {
@@ -1359,7 +_,7 @@
     private void completeStatusConsumers(ChunkStatus status, final ChunkAccess chunk) {
         // Update progress listener for LevelLoadingScreen
         if (chunk != null) {
-            final ChunkProgressListener progressListener = this.world.getChunkSource().chunkMap.progressListener;
+            final ChunkProgressListener progressListener = null; // Canvas - Threaded Regions
             if (progressListener != null) {
                 final ChunkStatus finalStatus = status;
                 this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
@@ -1383,7 +_,7 @@
         }
 
         // must be scheduled to main, we do not trust the callback to not do anything stupid
-        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+        this.scheduler.scheduleChunkTaskEventually(this.chunkX, this.chunkZ, () -> { // Canvas - Threaded Regions
             for (final Consumer<ChunkAccess> consumer : consumers) {
                 try {
                     consumer.accept(chunk);
@@ -1394,7 +_,7 @@
         }, Priority.HIGHEST);
     }
 
-    private final Reference2ObjectOpenHashMap<FullChunkStatus, List<Consumer<LevelChunk>>> fullStatusWaiters = new Reference2ObjectOpenHashMap<>();
+    private final Reference2ObjectMap<FullChunkStatus, List<Consumer<LevelChunk>>> fullStatusWaiters = it.unimi.dsi.fastutil.objects.Reference2ObjectMaps.synchronize(new Reference2ObjectOpenHashMap<>()); // Canvas - synchronized
 
     void addFullStatusConsumer(final FullChunkStatus status, final Consumer<LevelChunk> consumer) {
         this.fullStatusWaiters.computeIfAbsent(status, (final FullChunkStatus keyInMap) -> {
@@ -1411,7 +_,7 @@
         }
 
         // must be scheduled to main, we do not trust the callback to not do anything stupid
-        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+        this.scheduler.scheduleChunkTaskEventually(this.chunkX, this.chunkZ, () -> { // Canvas - Threaded Regions
             for (final Consumer<LevelChunk> consumer : consumers) {
                 try {
                     consumer.accept(chunk);
