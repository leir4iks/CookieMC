--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -28,6 +_,7 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Predicate;
 
 public final class ChunkEntitySlices {
@@ -40,8 +_,10 @@
 
     private final EntityCollectionBySection allEntities;
     private final EntityCollectionBySection hardCollidingEntities;
-    private final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
-    private final Reference2ObjectOpenHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
+    // Canvas start - Async target finding
+    private final Reference2ObjectMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
+    private final Reference2ObjectMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
+    // Canvas end - Async target finding
     private final EntityList entities = new EntityList();
 
     public FullChunkStatus status;
@@ -67,9 +_,15 @@
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
-        this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
-        this.entitiesByType = new Reference2ObjectOpenHashMap<>();
-
+        // Canvas start - Async target finding
+        if (io.canvasmc.canvas.Config.INSTANCE.entities.asyncTargetFinding.enabled) {
+            this.entitiesByClass = it.unimi.dsi.fastutil.objects.Reference2ObjectMaps.synchronize(new Reference2ObjectOpenHashMap<>());
+            this.entitiesByType = it.unimi.dsi.fastutil.objects.Reference2ObjectMaps.synchronize(new Reference2ObjectOpenHashMap<>());
+        } else {
+            this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
+            this.entitiesByType = new Reference2ObjectOpenHashMap<>();
+        }
+        // Canvas end - Async target finding
         this.status = status;
         this.chunkData = chunkData;
     }
@@ -203,8 +_,10 @@
         }
     }
 
+    public final ReentrantLock statusLock = new ReentrantLock(); // Canvas - status locks
     private boolean preventStatusUpdates;
     public boolean startPreventingStatusUpdates() {
+        this.statusLock.lock(); // Canvas - status locks
         final boolean ret = this.preventStatusUpdates;
         this.preventStatusUpdates = true;
         return ret;
@@ -216,9 +_,11 @@
 
     public void stopPreventingStatusUpdates(final boolean prev) {
         this.preventStatusUpdates = prev;
+        this.statusLock.unlock(); // Canvas - status locks
     }
 
     public void updateStatus(final FullChunkStatus status, final EntityLookup lookup) {
+        this.statusLock.lock(); try { // Canvas - chunk status locks
         this.status = status;
 
         final Entity[] entities = this.entities.getRawData();
@@ -232,9 +_,11 @@
 
             lookup.entityStatusChange(entity, this, oldVisibility, newVisibility, false, false, false);
         }
+        } finally { this.statusLock.unlock(); } // Canvas - chunk status locks
     }
 
     public boolean addEntity(final Entity entity, final int chunkSection) {
+        this.statusLock.lock(); try { // Canvas - chunk status locks
         if (!this.entities.add(entity)) {
             return false;
         }
@@ -248,14 +_,26 @@
             this.hardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
+        // Canvas start - Async target finding
+        if (io.canvasmc.canvas.Config.INSTANCE.entities.asyncTargetFinding.enabled) {
+            synchronized (this.entitiesByClass) {
+                for (final var entry : this.entitiesByClass.reference2ObjectEntrySet()) {
+                    if (entry.getKey().isInstance(entity)) {
+                        entry.getValue().addEntity(entity, sectionIndex);
+                    }
+                }
+            }
+        } else {
+            for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
+                 this.entitiesByClass.reference2ObjectEntrySet().iterator(); iterator.hasNext(); ) {
+                final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
 
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().addEntity(entity, sectionIndex);
+                if (entry.getKey().isInstance(entity)) {
+                    entry.getValue().addEntity(entity, sectionIndex);
+                }
             }
         }
+        // Canvas end - Async target finding
 
         EntityCollectionBySection byType = this.entitiesByType.get(entity.getType());
         if (byType != null) {
@@ -266,9 +_,11 @@
         }
 
         return true;
+        } finally { this.statusLock.unlock(); } // Canvas - chunk status locks
     }
 
     public boolean removeEntity(final Entity entity, final int chunkSection) {
+        this.statusLock.lock(); try { // Canvas - chunk status locks
         if (!this.entities.remove(entity)) {
             return false;
         }
@@ -282,19 +_,33 @@
             this.hardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
+        // Canvas start - Async target finding
+        if (io.canvasmc.canvas.Config.INSTANCE.entities.asyncTargetFinding.enabled) {
+            synchronized (this.entitiesByClass) {
+                for (final var entry : this.entitiesByClass.reference2ObjectEntrySet()) {
+                    if (entry.getKey().isInstance(entity)) {
+                        entry.getValue().removeEntity(entity, sectionIndex);
+                    }
+                }
+            }
+        } else {
+            for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
+                 this.entitiesByClass.reference2ObjectEntrySet().iterator(); iterator.hasNext();) {
+                final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
 
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().removeEntity(entity, sectionIndex);
+                if (entry.getKey().isInstance(entity)) {
+                    entry.getValue().removeEntity(entity, sectionIndex);
+                }
             }
         }
+        // Canvas end - Async target finding
+
 
         final EntityCollectionBySection byType = this.entitiesByType.get(entity.getType());
         byType.removeEntity(entity, sectionIndex);
 
         return true;
+        } finally { this.statusLock.unlock(); } // Canvas - chunk status locks
     }
 
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
