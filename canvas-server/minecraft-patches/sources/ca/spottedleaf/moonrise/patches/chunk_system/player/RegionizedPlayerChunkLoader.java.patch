--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -17,6 +_,10 @@
 import ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
 import com.google.gson.JsonObject;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
+import io.canvasmc.canvas.server.level.distance.command.DistanceUtils;
+import io.canvasmc.canvas.util.ConcurrentSet;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongComparator;
@@ -40,6 +_,7 @@
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
@@ -187,13 +_,25 @@
         }
 
         if (((ChunkSystemServerPlayer)player).moonrise$getChunkLoader() != null) {
-            throw new IllegalStateException("Player is already added to player chunk loader");
+            return; // Canvas - already added, ignore.
         }
 
         final PlayerChunkLoaderData loader = new PlayerChunkLoaderData(this.world, player);
 
-        ((ChunkSystemServerPlayer)player).moonrise$setChunkLoader(loader);
+        // Canvas start
+        // ((ChunkSystemServerPlayer)player).moonrise$setChunkLoader(loader); // move down
+        int viewDistance = DistanceUtils.resolveViewDistance(this.world);
+        loader.updateClientChunkRadius(viewDistance - 1);
+
+        int simulationDistance = DistanceUtils.resolveSimulationDistance(this.world);
+        loader.updateClientSimulationDistance(simulationDistance - 1);
         loader.add();
+        // ensure everything is ready before we mark the chunk loader in the player
+        // this helps prevent a race condition where another thread is requesting
+        // data from the chunk loader, and it hasn't finished init yet.
+        // to fix this, we init before setting the chunk loader inside the player object
+        player.moonrise$setChunkLoader(loader);
+        // Canvas end
     }
 
     public void updatePlayer(final ServerPlayer player) {
@@ -201,7 +_,7 @@
         if (loader != null) {
             loader.update();
             // update view distances for nearby players
-            ((ChunkSystemServerLevel)loader.world).moonrise$getNearbyPlayers().tickPlayer(player);
+            (loader.world).moonrise$getNearbyPlayers(player.chunkPosition()).tickPlayer(player); // Canvas - Threaded Regions
         }
     }
 
@@ -302,9 +_,9 @@
     public void tick() {
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
-        for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
+        for (final ServerPlayer player : new java.util.ArrayList<>(ServerRegions.getTickData(this.world).getLocalPlayers())) { // Canvas - Threaded Regions
             final PlayerChunkLoaderData loader = ((ChunkSystemServerPlayer)player).moonrise$getChunkLoader();
-            if (loader == null || loader.removed || loader.world != this.world) {
+            if (loader == null || loader.removed || loader.world != this.world || !loader.canTick) { // Canvas - can tick
                 // not our problem anymore
                 continue;
             }
@@ -323,6 +_,7 @@
 
         private final ServerPlayer player;
         private final ServerLevel world;
+        public volatile boolean canTick; // Canvas - can tick
 
         private int lastChunkX = Integer.MIN_VALUE;
         private int lastChunkZ = Integer.MIN_VALUE;
@@ -339,8 +_,8 @@
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas - concurrent
+        private final ConcurrentSet<Long> sentChunks = new ConcurrentSet<>(); // Canvas - concurrent
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
@@ -378,17 +_,21 @@
             final int centerX = PlayerChunkLoaderData.this.lastChunkX;
             final int centerZ = PlayerChunkLoaderData.this.lastChunkZ;
 
+            // Canvas start - use euclidian distance squared
             return Integer.compare(
-                Math.abs(c1x - centerX) + Math.abs(c1z - centerZ),
-                Math.abs(c2x - centerX) + Math.abs(c2z - centerZ)
+                (c1x - centerX) * (c1x - centerX) + (c1z - centerZ) * (c1z - centerZ),
+                (c2x - centerX) * (c2x - centerX) + (c2z - centerZ) * (c2z - centerZ)
             );
+            // Canvas end
         };
-        private final LongHeapPriorityQueue sendQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue tickingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue generatingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue genQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue loadingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue loadQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        // Canvas start - private -> public
+        public final LongHeapPriorityQueue sendQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue tickingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue generatingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue genQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue loadingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue loadQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        // Canvas end
 
         private volatile boolean removed;
 
@@ -409,7 +_,7 @@
             this.delayedTicketOps.addLast(op);
         }
 
-        private void sendChunk(final int chunkX, final int chunkZ) {
+        public void sendChunk(final int chunkX, final int chunkZ) { // Canvas - private -> public
             if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 ((ChunkSystemChunkHolder)((ChunkSystemServerLevel)this.world).moonrise$getChunkTaskScheduler().chunkHolderManager
                         .getChunkHolder(chunkX, chunkZ).vanillaChunkHolder).moonrise$addReceivedChunk(this.player);
@@ -423,7 +_,7 @@
             throw new IllegalStateException();
         }
 
-        private void sendUnloadChunk(final int chunkX, final int chunkZ) {
+        public void sendUnloadChunk(final int chunkX, final int chunkZ) { // Canvas - private -> public
             if (!this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 return;
             }
@@ -436,7 +_,15 @@
             // Note: drop isAlive() check so that chunks properly unload client-side when the player dies
             ((ChunkSystemChunkHolder)((ChunkSystemServerLevel)this.world).moonrise$getChunkTaskScheduler().chunkHolderManager
                 .getChunkHolder(chunkX, chunkZ).vanillaChunkHolder).moonrise$removeReceivedChunk(this.player);
-            this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)));
+            // Canvas start - async chunk send
+            if (Config.INSTANCE.chunks.chunkSending.asyncChunkSending) {
+                io.canvasmc.canvas.server.chunk.AsyncChunkSend.POOL.execute(
+                    () -> this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)))
+                );
+            } else {
+                this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)));
+            }
+            // Canvas end
             // Paper start - PlayerChunkUnloadEvent
             if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
                 new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(player.getBukkitEntity().getWorld().getChunkAt(new ChunkPos(chunkX, chunkZ).longKey), player.getBukkitEntity()).callEvent();
@@ -538,12 +_,12 @@
             );
         }
 
-        private Packet<?> updateClientChunkRadius(final int radius) {
+        public Packet<?> updateClientChunkRadius(final int radius) { // Canvas - private -> public
             this.lastSentChunkRadius = radius;
             return new ClientboundSetChunkCacheRadiusPacket(radius);
         }
 
-        private Packet<?> updateClientSimulationDistance(final int distance) {
+        public Packet<?> updateClientSimulationDistance(final int distance) { // Canvas - private -> public
             this.lastSentSimulationDistance = distance;
             return new ClientboundSetSimulationDistancePacket(distance);
         }
@@ -637,7 +_,7 @@
             return true;
         }
 
-        void updateQueues(final long time) {
+        synchronized void updateQueues(final long time) { // Canvas - synchronized
             TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
                 throw new IllegalStateException("Ticking removed player chunk loader");
@@ -822,7 +_,7 @@
                 final int pendingSendX = CoordinateUtils.getChunkX(pendingSend);
                 final int pendingSendZ = CoordinateUtils.getChunkZ(pendingSend);
                 final LevelChunk chunk = ((ChunkSystemLevel)this.world).moonrise$getFullChunkIfLoaded(pendingSendX, pendingSendZ);
-                if (!this.areNeighboursGenerated(pendingSendX, pendingSendZ, 1) || !TickThread.isTickThreadFor(this.world, pendingSendX, pendingSendZ)) {
+                if (!this.areNeighboursGenerated(pendingSendX, pendingSendZ, 1) || !io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(this.world, pendingSendX, pendingSendZ)) { // Canvas - Threaded Regions
                     // nothing to do
                     // the target chunk may not be owned by this region, but this should be resolved in the future
                     break;
@@ -849,6 +_,7 @@
         }
 
         void add() {
+            this.canTick = false; // Canvas - can tick
             TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Adding removed player chunk loader");
@@ -888,6 +_,7 @@
 
             // now we can update
             this.update();
+            this.canTick = true; // Canvas - can tick
         }
 
         private boolean isLoadedChunkGeneratable(final int chunkX, final int chunkZ) {
@@ -903,7 +_,7 @@
             );
         }
 
-        void update() {
+        synchronized void update() { // Canvas - synchronized
             TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Updating removed player chunk loader");
@@ -1056,6 +_,7 @@
         }
 
         void remove() {
+            this.canTick = false; // Canvas - can tick
             TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Removing removed player chunk loader");
@@ -1083,7 +_,7 @@
         }
 
         public LongOpenHashSet getSentChunksRaw() {
-            return this.sentChunks;
+            return new LongOpenHashSet(this.sentChunks); // Canvas
         }
     }
 }
