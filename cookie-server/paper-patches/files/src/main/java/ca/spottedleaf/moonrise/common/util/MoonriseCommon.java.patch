--- a/src/main/java/ca/spottedleaf/moonrise/common/util/MoonriseCommon.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/MoonriseCommon.java
@@ -12,83 +_,75 @@
 
     private static final Logger LOGGER = LogUtils.getClassLogger();
 
-    public static final PrioritisedThreadPool WORKER_POOL = new PrioritisedThreadPool(
-            new Consumer<>() {
-                private final AtomicInteger idGenerator = new AtomicInteger();
-
-                @Override
-                public void accept(Thread thread) {
-                    thread.setDaemon(true);
-                    thread.setName(PlatformHooks.get().getBrand() + " Common Worker #" + this.idGenerator.getAndIncrement());
-                    thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-                        @Override
-                        public void uncaughtException(final Thread thread, final Throwable throwable) {
-                            LOGGER.error("Uncaught exception in thread " + thread.getName(), throwable);
-                        }
-                    });
-                }
-            }
-    );
-    public static final long WORKER_QUEUE_HOLD_TIME = (long)(20.0e6); // 20ms
-    public static final int CLIENT_DIVISION = 0;
-    public static final PrioritisedThreadPool.ExecutorGroup RENDER_EXECUTOR_GROUP = MoonriseCommon.WORKER_POOL.createExecutorGroup(CLIENT_DIVISION, 0);
-    public static final int SERVER_DIVISION = 1;
-    public static final PrioritisedThreadPool.ExecutorGroup PARALLEL_GEN_GROUP = MoonriseCommon.WORKER_POOL.createExecutorGroup(SERVER_DIVISION, 0);
-    public static final PrioritisedThreadPool.ExecutorGroup RADIUS_AWARE_GROUP = MoonriseCommon.WORKER_POOL.createExecutorGroup(SERVER_DIVISION, 0);
-    public static final PrioritisedThreadPool.ExecutorGroup LOAD_GROUP         = MoonriseCommon.WORKER_POOL.createExecutorGroup(SERVER_DIVISION, 0);
-
-    public static void adjustWorkerThreads(final int configWorkerThreads, final int configIoThreads) {
-        int defaultWorkerThreads = Runtime.getRuntime().availableProcessors() / 2;
-        if (defaultWorkerThreads <= 4) {
-            defaultWorkerThreads = defaultWorkerThreads <= 3 ? 1 : 2;
-        } else {
-            defaultWorkerThreads = defaultWorkerThreads / 2;
-        }
-        defaultWorkerThreads = Integer.getInteger(PlatformHooks.get().getBrand() + ".WorkerThreadCount", Integer.valueOf(defaultWorkerThreads));
-
+    // cookie start - rewrite moonrise executor
+    public static io.cookiemc.cookie.server.chunk.TheChunkSystem WORKER_POOL;
+    public static io.cookiemc.cookie.server.chunk.TheChunkSystem.ExecutorGroup PARALLEL_GEN_GROUP;
+    public static io.cookiemc.cookie.server.chunk.TheChunkSystem.ExecutorGroup RADIUS_AWARE_GROUP;
+    public static io.cookiemc.cookie.server.chunk.TheChunkSystem.ExecutorGroup LOAD_GROUP;
+
+    public static void init(final int configWorkerThreads, final int configIoThreads) {
         int workerThreads = configWorkerThreads;
-
-        if (workerThreads <= 0) {
-            workerThreads = defaultWorkerThreads;
+        if (configWorkerThreads <= 0) {
+            // evaluate default
+            boolean isWindows = io.netty.util.internal.PlatformDependent.isWindows();
+            int cpus = Runtime.getRuntime().availableProcessors();
+            double memGb = Runtime.getRuntime().maxMemory() / 1024.0 / 1024.0 / 1024.0;
+
+            double cpuBased = isWindows ? (cpus / 1.6) : (cpus / 1.3);
+            double memBased = (memGb - 0.5) / 0.6;
+
+            workerThreads = (int) Math.max(1, Math.min(cpuBased, memBased));
         }
-
-        final int ioThreads = Math.max(1, configIoThreads);
-
-        WORKER_POOL.adjustThreadCount(workerThreads);
+        int ioThreads = Math.max(1, configIoThreads);
+
+        WORKER_POOL = buildChunkSystem(workerThreads);
+
+        PARALLEL_GEN_GROUP = MoonriseCommon.WORKER_POOL.createExecutorGroup();
+        RADIUS_AWARE_GROUP = MoonriseCommon.WORKER_POOL.createExecutorGroup();
+        LOAD_GROUP = MoonriseCommon.WORKER_POOL.createExecutorGroup();
+
         IO_POOL.adjustThreadCount(ioThreads);
+        LOGGER.info("Running LS ChunkSystem with {} worker threads and {} io threads", workerThreads, ioThreads);
+    }
 
-        LOGGER.info(PlatformHooks.get().getBrand() + " is using " + workerThreads + " worker threads, " + ioThreads + " I/O threads");
+    private static @org.jetbrains.annotations.NotNull io.cookiemc.cookie.server.chunk.TheChunkSystem buildChunkSystem(int workerThreads) {
+        return new io.cookiemc.cookie.server.chunk.TheChunkSystem(workerThreads, new io.cookiemc.cookie.util.ThreadBuilder() {
+            @Override
+            public void accept(final Thread thread) {
+                thread.setPriority(io.cookiemc.cookie.Config.INSTANCE.chunks.threadPoolPriority);
+                thread.setDaemon(true);
+                thread.setUncaughtExceptionHandler((thread1, throwable) -> LOGGER.error("Uncaught exception in thread {}", thread1.getName(), throwable));
+                thread.setName("ls_wg worker #" + getAndIncrementId());
+            }
+        }, "ls_wg");
     }
+    // cookie end
 
     public static final PrioritisedThreadPool IO_POOL = new PrioritisedThreadPool(
-            new Consumer<>() {
-                private final AtomicInteger idGenerator = new AtomicInteger();
-
-                @Override
-                public void accept(final Thread thread) {
-                    thread.setDaemon(true);
-                    thread.setName(PlatformHooks.get().getBrand() + " I/O Worker #" + this.idGenerator.getAndIncrement());
-                    thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-                        @Override
-                        public void uncaughtException(final Thread thread, final Throwable throwable) {
-                            LOGGER.error("Uncaught exception in thread " + thread.getName(), throwable);
-                        }
-                    });
-                }
+        new Consumer<>() {
+            private final AtomicInteger idGenerator = new AtomicInteger();
+            @Override
+            public void accept(final Thread thread) {
+                thread.setDaemon(true);
+                thread.setName(PlatformHooks.get().getBrand() + " I/O Worker #" + this.idGenerator.getAndIncrement());
+                thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+                    @Override
+                    public void uncaughtException(final Thread thread, final Throwable throwable) {
+                        LOGGER.error("Uncaught exception in thread " + thread.getName(), throwable);
+                    }
+                });
             }
+        }
     );
     public static final long IO_QUEUE_HOLD_TIME = (long)(100.0e6); // 100ms
-    public static final PrioritisedThreadPool.ExecutorGroup CLIENT_PROFILER_IO_GROUP = IO_POOL.createExecutorGroup(CLIENT_DIVISION, 0);
-    public static final PrioritisedThreadPool.ExecutorGroup SERVER_REGION_IO_GROUP = IO_POOL.createExecutorGroup(SERVER_DIVISION, 0);
+    // cookie
+    public static final PrioritisedThreadPool.ExecutorGroup SERVER_REGION_IO_GROUP = IO_POOL.createExecutorGroup(1, 0);
 
     public static void haltExecutors() {
-        MoonriseCommon.WORKER_POOL.shutdown(false);
-        LOGGER.info("Awaiting termination of worker pool for up to 60s...");
-        if (!MoonriseCommon.WORKER_POOL.join(TimeUnit.SECONDS.toMillis(60L))) {
-            LOGGER.error("Worker pool did not shut down in time!");
-            MoonriseCommon.WORKER_POOL.halt(false);
-        }
-
+        // cookie start
+        LOGGER.info("Terminating ChunkSystem...");
+        MoonriseCommon.WORKER_POOL.shutdown();
+        // cookie end
         MoonriseCommon.IO_POOL.shutdown(false);
         LOGGER.info("Awaiting termination of I/O pool for up to 60s...");
         if (!MoonriseCommon.IO_POOL.join(TimeUnit.SECONDS.toMillis(60L))) {
